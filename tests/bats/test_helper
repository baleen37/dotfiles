# BATS Test Helper Functions (Phase 3)
# Enhanced utilities and assertions with cross-platform stability and performance optimization

# Color codes for output
export RED='\033[0;31m'
export GREEN='\033[0;32m'
export YELLOW='\033[1;33m'
export BLUE='\033[0;34m'
export NC='\033[0m' # No Color

# Phase 3: Enhanced test environment detection
export IS_CI="${CI:-false}"
export IS_GITHUB_ACTIONS="${GITHUB_ACTIONS:-false}"
export PHASE3_OPTIMIZATION="${PHASE3_OPTIMIZATION:-true}"
export BATS_PERFORMANCE_MODE="${BATS_PERFORMANCE_MODE:-ultimate}"
export BATS_MEMORY_LIMIT_MB="${BATS_MEMORY_LIMIT_MB:-512}"

# Phase 3: Cross-platform compatibility detection
detect_platform() {
    case "$(uname -s)" in
        Darwin*) echo "darwin" ;;
        Linux*)  echo "linux" ;;
        CYGWIN*) echo "windows" ;;
        MINGW*)  echo "windows" ;;
        *)       echo "unknown" ;;
    esac
}

export PLATFORM="$(detect_platform)"
export IS_DARWIN="$([[ "$PLATFORM" == "darwin" ]] && echo "true" || echo "false")"
export IS_LINUX="$([[ "$PLATFORM" == "linux" ]] && echo "true" || echo "false")"

# Phase 3: Enhanced project paths with validation
export PROJECT_ROOT="${PROJECT_ROOT:-$(git rev-parse --show-toplevel 2>/dev/null || pwd)}"
export LIB_DIR="$PROJECT_ROOT/lib"
export MODULES_DIR="$PROJECT_ROOT/modules"
export TESTS_DIR="$PROJECT_ROOT/tests"
export CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/dotfiles-tests"
export PHASE3_CACHE_DIR="$CACHE_DIR/phase3"

# Phase 3: Ensure cache directories exist
init_phase3_cache() {
    mkdir -p "$PHASE3_CACHE_DIR" 2>/dev/null || true
    # Create cache subdirectories
    mkdir -p "$PHASE3_CACHE_DIR/nix-eval" 2>/dev/null || true
    mkdir -p "$PHASE3_CACHE_DIR/test-results" 2>/dev/null || true
    mkdir -p "$PHASE3_CACHE_DIR/performance" 2>/dev/null || true
}

# Initialize on load
if [[ "$PHASE3_OPTIMIZATION" = "true" ]]; then
    init_phase3_cache
fi

# Common assertions
assert_file_exists() {
    local file="$1"
    [ -f "$file" ] || {
        echo "Expected file to exist: $file" >&2
        return 1
    }
}

assert_directory_exists() {
    local dir="$1"
    [ -d "$dir" ] || {
        echo "Expected directory to exist: $dir" >&2
        return 1
    }
}

assert_command_exists() {
    local cmd="$1"
    command -v "$cmd" >/dev/null 2>&1 || {
        echo "Expected command to exist: $cmd" >&2
        return 1
    }
}

# Phase 3: Enhanced Nix evaluation with caching and error handling
assert_nix_eval() {
    local expr="$1"
    local expected="$2"
    local cache_key="$(echo "$expr" | sha256sum 2>/dev/null | cut -d' ' -f1 || echo "nocache")"
    local cache_file="/tmp/bats_nix_cache_${cache_key}"

    local result

    # Phase 3: Try cache first
    if [[ -f "$cache_file" && "$IS_CI" = "true" ]]; then
        result=$(cat "$cache_file")
        log_info "Using cached Nix evaluation result"
    else
        # Evaluate with timeout and error handling
        if result=$(compat_timeout 30s nix eval --impure --expr "$expr" 2>/dev/null | tr -d '"'); then
            # Cache successful result in CI
            if [[ "$IS_CI" = "true" && -n "$result" ]]; then
                echo "$result" > "$cache_file"
            fi
        else
            log_error "Nix evaluation failed or timed out"
            echo "Expression: $expr" >&2
            return 1
        fi
    fi

    [ "$result" = "$expected" ] || {
        echo "Expected: $expected" >&2
        echo "Got: $result" >&2
        echo "Expression: $expr" >&2
        # Clean cache on mismatch
        rm -f "$cache_file" 2>/dev/null || true
        return 1
    }
}

assert_contains() {
    local haystack="$1"
    local needle="$2"

    [[ "$haystack" == *"$needle"* ]] || {
        echo "Expected '$haystack' to contain '$needle'" >&2
        return 1
    }
}

# Phase 3: Enhanced skip helpers with platform awareness
skip_if_ci() {
    [ "$IS_CI" = "true" ] && skip "${1:-Skipping in CI environment}"
}

skip_if_not_darwin() {
    [ "$IS_DARWIN" != "true" ] && skip "${1:-Skipping on non-Darwin systems}"
}

skip_if_not_linux() {
    [ "$IS_LINUX" != "true" ] && skip "${1:-Skipping on non-Linux systems}"
}

# Phase 3: Additional platform-aware skip helpers
skip_if_low_memory() {
    local min_memory_mb="${1:-1024}"  # 1GB default
    local available_memory_mb

    available_memory_mb=$(( $(get_memory_usage_kb) / 1024 ))

    if [[ $available_memory_mb -lt $min_memory_mb ]]; then
        skip "Insufficient memory: ${available_memory_mb}MB < ${min_memory_mb}MB"
    fi
}

skip_if_performance_mode_disabled() {
    [ "$BATS_PERFORMANCE_MODE" = "disabled" ] && skip "Performance mode disabled"
}

skip_if_phase3_disabled() {
    [ "$PHASE3_OPTIMIZATION" != "true" ] && skip "Phase 3 optimizations disabled"
}

# Test data helpers
create_temp_config() {
    local config_file="$1"
    local content="$2"

    mkdir -p "$(dirname "$config_file")"
    echo "$content" > "$config_file"
}

# Output helpers
log_info() {
    echo -e "${BLUE}[INFO]${NC} $*" >&2
}

log_warning() {
    echo -e "${YELLOW}[WARN]${NC} $*" >&2
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $*" >&2
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $*" >&2
}

# Phase 3: Enhanced performance measurement
start_timer() {
    if command -v date >/dev/null 2>&1; then
        # High-resolution timing where available
        if date +%s%N >/dev/null 2>&1; then
            export TEST_START_TIME=$(date +%s%N)
            export TIMER_PRECISION="nanoseconds"
        else
            export TEST_START_TIME=$(date +%s)
            export TIMER_PRECISION="seconds"
        fi
    else
        export TEST_START_TIME="0"
        export TIMER_PRECISION="unavailable"
    fi

    # Phase 3: Initialize memory baseline
    export TEST_MEMORY_BASELINE=$(get_memory_usage_kb 2>/dev/null || echo "0")
}

end_timer() {
    local end_time duration memory_usage memory_delta

    case "$TIMER_PRECISION" in
        "nanoseconds")
            end_time=$(date +%s%N)
            duration=$(( (end_time - TEST_START_TIME) / 1000000 ))
            log_info "Test duration: ${duration}ms (high precision)"
            ;;
        "seconds")
            end_time=$(date +%s)
            duration=$((end_time - TEST_START_TIME))
            log_info "Test duration: ${duration}s"
            ;;
        *)
            log_info "Test completed (timing unavailable)"
            ;;
    esac

    # Phase 3: Memory usage analysis
    memory_usage=$(get_memory_usage_kb 2>/dev/null || echo "0")
    if [[ "$memory_usage" -gt 0 && "$TEST_MEMORY_BASELINE" -gt 0 ]]; then
        memory_delta=$((memory_usage - TEST_MEMORY_BASELINE))
        if [[ $memory_delta -gt 0 ]]; then
            log_info "Memory delta: +${memory_delta}KB"
            # Warning for excessive memory usage
            if [[ $memory_delta -gt 102400 ]]; then  # 100MB
                log_warning "High memory usage detected: ${memory_delta}KB"
            fi
        fi
    fi
}

# Phase 3: Cross-platform memory usage
get_memory_usage_kb() {
    case "$PLATFORM" in
        "linux")
            if command -v free >/dev/null 2>&1; then
                free -k | awk '/^Mem:/ {print $3}'
            else
                ps -o rss= -p $$ | awk '{print $1}'
            fi
            ;;
        "darwin")
            # macOS memory detection
            if command -v vm_stat >/dev/null 2>&1; then
                local page_size=$(vm_stat | grep "page size" | awk '{print $8}' | tr -d '.' || echo "4096")
                local pages_used=$(vm_stat | grep -E "(Pages active|Pages inactive|Pages wired)" | awk '{sum += $3} END {print sum}' | tr -d '.')
                echo $(( (pages_used * page_size) / 1024 ))
            else
                ps -o rss= -p $$ | awk '{print $1}'
            fi
            ;;
        *)
            ps -o rss= -p $$ 2>/dev/null | awk '{print $1}' || echo "0"
            ;;
    esac
}

# Phase 3: Enhanced cleanup helpers with memory optimization
cleanup_nix_store() {
    # Enhanced cleanup for Phase 3 optimization
    if [ "$IS_CI" = "true" ] || [ "$PHASE3_OPTIMIZATION" = "true" ]; then
        log_info "Phase 3: Performing optimized Nix store cleanup..."

        # Clean evaluation cache first (lightweight)
        rm -rf ~/.cache/nix/eval-cache-v* 2>/dev/null || true

        # Clean temporary build artifacts
        rm -rf /tmp/nix-build-* 2>/dev/null || true

        # Garbage collection with optimized settings
        if command -v nix >/dev/null 2>&1; then
            # Phase 3: More aggressive cleanup in CI
            if [ "$IS_CI" = "true" ]; then
                nix store gc --option keep-going true --option max-jobs 2 >/dev/null 2>&1 || true
                nix store optimise --option keep-going true >/dev/null 2>&1 || true
            else
                # Conservative cleanup for development
                nix-collect-garbage -d --option keep-going true >/dev/null 2>&1 || true
            fi
        fi

        log_info "Cleanup completed"
    fi
}

# Phase 3: Memory-aware test execution
run_with_memory_limit() {
    local memory_limit="${BATS_MEMORY_LIMIT_MB:-512}"
    local command="$*"

    # Check current memory usage
    local current_memory_mb
    current_memory_mb=$(( $(get_memory_usage_kb) / 1024 ))

    if [[ $current_memory_mb -gt $memory_limit ]]; then
        log_warning "Memory usage (${current_memory_mb}MB) exceeds limit (${memory_limit}MB)"

        # Attempt cleanup
        cleanup_nix_store
        sleep 2

        # Recheck after cleanup
        current_memory_mb=$(( $(get_memory_usage_kb) / 1024 ))
        if [[ $current_memory_mb -gt $memory_limit ]]; then
            log_error "Memory limit still exceeded after cleanup: ${current_memory_mb}MB"
            return 1
        fi
    fi

    # Execute command
    eval "$command"
}

# Phase 3: Performance-aware assertions
assert_performance_acceptable() {
    local duration_ms="$1"
    local memory_kb="$2"
    local max_duration_ms="${3:-5000}"  # 5 seconds default
    local max_memory_kb="${4:-102400}"   # 100MB default

    if [[ $duration_ms -gt $max_duration_ms ]]; then
        log_error "Performance regression: duration ${duration_ms}ms > ${max_duration_ms}ms"
        return 1
    fi

    if [[ $memory_kb -gt $max_memory_kb ]]; then
        log_error "Memory regression: usage ${memory_kb}KB > ${max_memory_kb}KB"
        return 1
    fi

    log_success "Performance acceptable: ${duration_ms}ms, ${memory_kb}KB"
}

# Phase 3: Cross-platform command compatibility
compat_timeout() {
    local duration="$1"
    shift

    if command -v timeout >/dev/null 2>&1; then
        timeout "$duration" "$@"
    elif command -v gtimeout >/dev/null 2>&1; then
        gtimeout "$duration" "$@"
    else
        # Fallback: no timeout (not ideal but better than failing)
        log_warning "No timeout command available, running without timeout"
        "$@"
    fi
}
