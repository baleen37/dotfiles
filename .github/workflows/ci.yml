name: CI
on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

env:
  NIX_CONFIG: |
    max-jobs = auto
    cores = 0
    substituters = https://cache.nixos.org https://nix-community.cachix.org
    trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=
  # Single environment variable to control entire pipeline
  CI_MODE: ${{ github.event.pull_request.draft == true && 'draft' || 'full' }}
  IS_MAIN: ${{ github.ref == 'refs/heads/main' }}

jobs:
  # Fast validation stage (1-2 minutes)
  validate:
    name: Validate & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show CI mode
        run: |
          echo "ğŸ¯ CI Mode: $CI_MODE"
          echo "ğŸ“ Is Main: $IS_MAIN"

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      - name: Cache Nix store
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
          key: validate-nix-${{ hashFiles('flake.lock') }}
          restore-keys: validate-nix-
          # Use built-in tar instead of GNU tar to avoid issues
          enableCrossOsArchive: false

      - name: Lint
        run: |
          nix-shell -p pre-commit --run "pre-commit install"
          nix-shell -p pre-commit --run "pre-commit run --all-files"

      - name: Validate flake
        run: |
          echo "Debug: USER before export: '$USER'"
          echo "Debug: SUDO_USER: '$SUDO_USER'"
          echo "Debug: whoami: $(whoami)"
          export USER=${USER:-ci}
          echo "Debug: USER after export: '$USER'"
          nix flake check --impure --no-build --all-systems

  # Core build stage (2-4 minutes) - Only essential platforms
  build-core:
    name: Build ${{ matrix.name }}
    needs: validate
    if: (github.event.pull_request.draft != true) || (github.ref == 'refs/heads/main')
    strategy:
      fail-fast: false
      matrix:
        include:
          - name: "Darwin ARM64"
            system: aarch64-darwin
            os: macos-14
            build_type: full
          - name: "Linux x64"
            system: x86_64-linux
            os: ubuntu-latest
            build_type: full
          - name: "Darwin x64"
            system: x86_64-darwin
            os: macos-13
            build_type: validate
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.name == 'Darwin ARM64' }}  # Mark Darwin ARM64 as optional due to runner issues
    steps:
      - uses: actions/checkout@v4

      # Clean up any existing Nix installation on macOS
      - name: Clean existing Nix installation (macOS)
        if: runner.os == 'macOS'
        run: |
          echo "ğŸ§¹ Cleaning existing Nix installation..."

          # More conservative cleanup for macOS 15 compatibility
          sudo launchctl stop org.nixos.nix-daemon 2>/dev/null || true
          sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist 2>/dev/null || true

          # Only remove Nix directory and configs - avoid user/group manipulation on macOS 15
          sudo umount /nix 2>/dev/null || true
          sudo rm -rf /nix 2>/dev/null || true
          sudo rm -f /etc/synthetic.conf 2>/dev/null || true
          sudo rm -f /Library/LaunchDaemons/org.nixos.* 2>/dev/null || true
          sudo rm -rf /etc/nix 2>/dev/null || true

          # Prepare for fresh install
          echo "nix" | sudo tee /etc/synthetic.conf > /dev/null 2>&1 || true

          echo "âœ… macOS cleanup completed"

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      - name: Cache Nix store
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
          key: ${{ runner.os }}-${{ matrix.system }}-${{ hashFiles('flake.lock') }}
          restore-keys: |
            ${{ runner.os }}-${{ matrix.system }}-
            ${{ runner.os }}-nix-
            validate-nix-
          # Use built-in tar instead of GNU tar to avoid issues
          enableCrossOsArchive: false

      - name: Build configuration
        timeout-minutes: 90
        run: |
          export USER=${USER:-ci}
          echo "ğŸ—ï¸ Building ${{ matrix.name }} (${{ matrix.system }}) - Type: ${{ matrix.build_type }}"

          case "${{ matrix.system }}" in
            *darwin*)
              if [[ "${{ matrix.build_type }}" == "full" ]]; then
                echo "Running full Darwin build..."
                nix build --impure --no-link .#darwinConfigurations.${{ matrix.system }}.system
              else
                echo "Running Darwin validation..."
                nix eval --impure .#darwinConfigurations.${{ matrix.system }}.system --json >/dev/null
              fi
              ;;
            *linux*)
              echo "Running NixOS validation..."
              nix eval --impure .#nixosConfigurations.${{ matrix.system }}.config.system.name --json >/dev/null
              ;;
          esac
          echo "âœ… Build completed successfully"

  # Parallel test stage (2-3 minutes)
  test-parallel:
    name: Test ${{ matrix.category }}
    needs: [validate, build-core]
    if: (github.event.pull_request.draft != true) || (github.ref == 'refs/heads/main')
    strategy:
      fail-fast: false
      matrix:
        category: [unit, integration, perf]
    runs-on: macos-14
    steps:
      - uses: actions/checkout@v4

      # Clean up any existing Nix installation on macOS
      - name: Clean existing Nix installation (macOS)
        run: |
          echo "ğŸ§¹ Cleaning existing Nix installation for tests..."

          # Conservative cleanup for test environment
          sudo launchctl stop org.nixos.nix-daemon 2>/dev/null || true
          sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist 2>/dev/null || true

          # Remove only Nix files and directories
          sudo umount /nix 2>/dev/null || true
          sudo rm -rf /nix 2>/dev/null || true
          sudo rm -f /etc/synthetic.conf /Library/LaunchDaemons/org.nixos.* 2>/dev/null || true
          echo "nix" | sudo tee /etc/synthetic.conf > /dev/null 2>&1 || true

          echo "âœ… Test cleanup completed"

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      - name: Restore Nix cache
        uses: actions/cache/restore@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
          key: macOS-aarch64-darwin-${{ hashFiles('flake.lock') }}
          restore-keys: |
            macOS-aarch64-darwin-
            validate-nix-
          # Use built-in tar instead of GNU tar to avoid issues
          enableCrossOsArchive: false

      - name: Run tests
        timeout-minutes: 30
        run: |
          export USER=${USER:-ci}

          # Nix í™˜ê²½ ì´ˆê¸°í™” (CIì—ì„œ PATH ì„¤ì •)
          if [[ -e /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh ]]; then
            source /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
          fi

          # Nix ë„êµ¬ë“¤ì´ PATHì— ìˆëŠ”ì§€ í™•ì¸
          if ! command -v nix-instantiate >/dev/null 2>&1; then
            echo "âš ï¸ nix-instantiate not found in PATH"
            echo "PATH: $PATH"
            echo "Available nix commands:"
            which nix || echo "nix not found"
            find /nix -name "nix-instantiate" 2>/dev/null || echo "nix-instantiate not found in /nix"
          else
            echo "âœ… nix-instantiate available"
          fi

          echo "ğŸ§ª Running ${{ matrix.category }} tests"
          echo "Debug: Current working directory: $(pwd)"
          echo "Debug: Available test files:"
          find tests -name "*${{ matrix.category }}*" || echo "No test files found"

          # Run test with verbose output
          nix run --impure .#test-${{ matrix.category }} 2>&1 | tee test-output.log

          # Show exit code
          exit_code=$?
          echo "Test exit code: $exit_code"

          # Show test output summary
          if [[ -f test-output.log ]]; then
            echo "=== Test Output Summary ==="
            tail -20 test-output.log
          fi

          exit $exit_code

  # Smoke test for all PRs (30 seconds)
  smoke-test:
    name: Smoke Test
    needs: validate
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      - name: Quick smoke test
        run: |
          export USER=${USER:-ci}
          nix flake check --impure --no-build --all-systems
          echo "âœ… Smoke test passed - Draft PR validation complete"

  # Summary and status reporting
  ci-complete:
    name: CI Summary
    needs: [validate, build-core, test-parallel, smoke-test]
    runs-on: ubuntu-latest
    if: always() && !cancelled()
    # Force this job to run even if previous jobs fail
    continue-on-error: false
    steps:
      - name: Determine overall status
        id: status
        run: |
          validation_result="${{ needs.validate.result }}"
          build_result="${{ needs.build-core.result }}"
          test_result="${{ needs.test-parallel.result }}"
          smoke_result="${{ needs.smoke-test.result }}"

          echo "Debug: validation_result=$validation_result"
          echo "Debug: build_result=$build_result"
          echo "Debug: test_result=$test_result"
          echo "Debug: smoke_result=$smoke_result"
          echo "Debug: CI_MODE=$CI_MODE"
          echo "Debug: github.event_name=${{ github.event_name }}"

          # Simplified status determination logic
          if [[ "$validation_result" != "success" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Validation failed" >> $GITHUB_OUTPUT
          elif [[ "$CI_MODE" == "draft" ]]; then
            if [[ "$smoke_result" == "success" ]]; then
              echo "status=success" >> $GITHUB_OUTPUT
              echo "message=Draft PR validation passed (smoke test only)" >> $GITHUB_OUTPUT
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "message=Draft PR smoke test failed" >> $GITHUB_OUTPUT
            fi
          else
            # For main branch (push events), smoke test is skipped
            if [[ "${{ github.event_name }}" == "push" ]]; then
              if [[ "$build_result" == "success" && ("$test_result" == "success" || "$test_result" == "skipped") ]]; then
                echo "status=success" >> $GITHUB_OUTPUT
                echo "message=Full CI pipeline completed successfully" >> $GITHUB_OUTPUT
              else
                echo "status=failed" >> $GITHUB_OUTPUT
                echo "message=Build or test stage failed (build: $build_result, test: $test_result)" >> $GITHUB_OUTPUT
              fi
            else
              # For PR events, include smoke test
              if [[ "$build_result" == "success" && ("$test_result" == "success" || "$test_result" == "skipped") && "$smoke_result" == "success" ]]; then
                echo "status=success" >> $GITHUB_OUTPUT
                echo "message=Full CI pipeline completed successfully" >> $GITHUB_OUTPUT
              else
                echo "status=failed" >> $GITHUB_OUTPUT
                echo "message=Build, test, or smoke test stage failed (build: $build_result, test: $test_result, smoke: $smoke_result)" >> $GITHUB_OUTPUT
              fi
            fi
          fi

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Helper functions for cleaner code
              function getStatusIcon(result) {
                return result === 'success' ? 'âœ…' : 'âŒ';
              }

              function buildTemplate(isDraft, statusIcon, message, icons, footer) {
                const efficiency = isDraft ? 'âš¡ **Ultra Fast** (smoke test only)' : 'ğŸš€ **Streamlined** (parallel execution)';
                const buildStatus = isDraft ? 'â­ï¸ Skipped (draft)' : icons.build + ' Core platforms';
                const testStatus = isDraft ? 'â­ï¸ Skipped (draft)' : icons.test + ' Parallel execution';

                return '## ' + statusIcon + ' Streamlined CI Results\n\n' +
                  efficiency + '\n\n' +
                  '**Status**: ' + message + '\n\n' +
                  '**Pipeline Summary**:\n' +
                  '- **Validation**: ' + icons.validation + ' Lint & flake check\n' +
                  '- **Build**: ' + buildStatus + '\n' +
                  '- **Tests**: ' + testStatus + '\n' +
                  '- **Smoke Test**: ' + icons.smoke + ' Quick validation\n\n' +
                  footer;
              }

              // Main logic
              const status = '${{ steps.status.outputs.status }}';
              const message = '${{ steps.status.outputs.message }}';
              const isDraft = '${{ env.CI_MODE }}' === 'draft';

              const statusIcon = getStatusIcon(status);
              const icons = {
                validation: getStatusIcon('${{ needs.validate.result }}'),
                build: getStatusIcon('${{ needs.build-core.result }}'),
                test: getStatusIcon('${{ needs.test-parallel.result }}'),
                smoke: getStatusIcon('${{ needs.smoke-test.result }}')
              };

              const footer = isDraft ? '_ğŸ’¡ Mark as ready to run full CI pipeline_' : '_ğŸ¯ Optimized for speed: ~5-8 minutes total_';
              const template = buildTemplate(isDraft, statusIcon, message, icons, footer);

              // Find and update existing comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const existingComment = comments.find(comment =>
                comment.user.type === 'Bot' && comment.body.includes('Streamlined CI Results')
              );

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: template
                });
                console.log('Updated existing CI comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: template
                });
                console.log('Created new CI comment');
              }
            } catch (error) {
              console.error('Failed to update PR comment:', error);
              // Continue workflow even if comment fails
            }

      - name: Report CI status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          status="${{ steps.status.outputs.status }}"
          message="${{ steps.status.outputs.message }}"
          state=$([ "$status" = "success" ] && echo "success" || echo "failure")

          echo "ğŸ” Setting CI status: $state - $message"
          echo "ğŸ“ SHA: ${{ github.sha }}"
          echo "ğŸ”— Run ID: ${{ github.run_id }}"

          # Primary attempt: Use gh CLI
          if gh api repos/baleen37/dotfiles/statuses/${{ github.sha }} \
            -X POST \
            -f state="$state" \
            -f description="$message" \
            -f context="CI" \
            -f target_url="https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}" \
            --verbose; then
            echo "âœ… CI status reported successfully via gh CLI"
          else
            echo "âš ï¸ gh CLI failed, trying curl fallback..."

            # Fallback: Use curl directly
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{\"state\":\"$state\",\"description\":\"$message\",\"context\":\"CI\",\"target_url\":\"https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}\"}" \
              https://api.github.com/repos/baleen37/dotfiles/statuses/${{ github.sha }}

            echo "âœ… CI status reported via curl fallback"
          fi

          # Verify the status was set
          echo "ğŸ” Verifying CI status was set..."
          gh api repos/baleen37/dotfiles/commits/${{ github.sha }}/statuses --jq '.[] | select(.context == "CI") | {state: .state, description: .description}'

      - name: Final status check
        run: |
          status="${{ steps.status.outputs.status }}"
          message="${{ steps.status.outputs.message }}"

          if [[ "$status" != "success" ]]; then
            echo "âŒ CI pipeline failed: $message"
            exit 1
          else
            echo "âœ… CI pipeline succeeded: $message"
          fi

  # Fallback job in case ci-complete fails
  ci-status-fallback:
    name: CI Status Fallback
    needs: [validate, build-core, test-parallel, smoke-test]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && (failure() || needs.ci-complete.result == 'failure')
    steps:
      - name: Emergency CI Status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸš¨ CI Summary job failed, setting emergency status"

          # Always report failure if we reach this point
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            -d '{"state":"failure","description":"CI pipeline failed or incomplete","context":"CI","target_url":"https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}"}' \
            https://api.github.com/repos/baleen37/dotfiles/statuses/${{ github.sha }}

          echo "âœ… Emergency CI status set to failure"

  # Auto-merge for all PRs after successful CI
  auto-merge:
    name: Auto-merge PR
    needs: ci-complete
    runs-on: ubuntu-latest
    if: >
      needs.ci-complete.result == 'success' &&
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-approve and enable auto-merge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸš€ Auto-merging PR #${{ github.event.number }}"
          echo "Author: ${{ github.event.pull_request.user.login }}"

          # Check if author is repo owner
          author="${{ github.event.pull_request.user.login }}"
          repo_owner="${{ github.repository_owner }}"

          if [[ "$author" == "$repo_owner" ]]; then
            echo "ğŸ”§ Repo owner PR detected - GitHub prevents self-approval"
            echo "âœ… Relying on successful CI for merge qualification"
            echo "ğŸ¯ Branch protection allows admin bypass for repo owner"
          else
            echo "ğŸ‘¤ External contributor - auto-approving PR"
            # Auto-approve the PR for external contributors
            gh pr review ${{ github.event.number }} --approve \
              --body "âœ… **Auto-approved**: CI íŒŒì´í”„ë¼ì¸ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.

            - **ìƒíƒœ**: ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼ âœ…
            - **ë¹Œë“œ**: ì„±ê³µ âœ…
            - **ê²€ì¦**: ì™„ë£Œ âœ…

            _ğŸ¤– ìë™í™”ëœ ìŠ¹ì¸ ë° ë¨¸ì§€ í”„ë¡œì„¸ìŠ¤_"
          fi

          # Enable auto-merge (works for both cases due to admin bypass)
          gh pr merge ${{ github.event.number }} --auto --squash

          echo "âœ… Auto-merge enabled for PR #${{ github.event.number }}"
          echo "PR will automatically merge when all conditions are met (including approvals)"

# PR #312 CI íŠ¸ë¦¬ê±° í™•ì¸ìš© ì£¼ì„
