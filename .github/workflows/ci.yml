name: CI
on:
  push:
    branches: [main]
  pull_request:
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: write
  issues: write
  statuses: write

env:
  NIX_CONFIG: |
    max-jobs = auto
    cores = 0
    substituters = https://cache.nixos.org https://nix-community.cachix.org
    trusted-public-keys = cache.nixos.org-1:6NCHdD59X431o0gWypbMrAURkbJ16ZPMQFGspcDShjY= nix-community.cachix.org-1:mB9FSh9qf2dCimDSUo8Zy7bkq5CX+/rkCWyvRCYg3Fs=
  # Single environment variable to control entire pipeline
  CI_MODE: ${{ github.event.pull_request.draft == true && 'draft' || 'full' }}
  IS_MAIN: ${{ github.ref == 'refs/heads/main' }}

jobs:
  # Fast validation stage (1-2 minutes)
  validate:
    name: Validate & Lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Show CI mode
        run: |
          echo "ğŸ¯ CI Mode: $CI_MODE"
          echo "ğŸ“ Is Main: $IS_MAIN"

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      # Phase 3: Enhanced caching with intelligent layering
      - name: Cache Nix store (Phase 3 optimization)
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
            ~/.cache/nix-index
            /tmp/nix-build-*
          key: phase3-validate-nix-${{ hashFiles('flake.lock', 'flake.nix') }}-${{ runner.os }}
          restore-keys: |
            phase3-validate-nix-${{ hashFiles('flake.lock', 'flake.nix') }}-
            phase3-validate-nix-${{ hashFiles('flake.lock') }}-
            validate-nix-${{ hashFiles('flake.lock') }}
            validate-nix-
          # Phase 3: Multi-layer cache strategy
          enableCrossOsArchive: false
          save-always: true

      - name: Lint
        run: |
          # Unset core.hooksPath if set (prevents pre-commit installation errors)
          git config --unset-all core.hooksPath || true
          nix-shell -p pre-commit --run "pre-commit install"
          nix-shell -p pre-commit --run "pre-commit run --all-files"

      - name: Validate flake
        run: |
          echo "Debug: USER before export: '$USER'"
          echo "Debug: SUDO_USER: '$SUDO_USER'"
          echo "Debug: whoami: $(whoami)"
          export USER=${USER:-ci}
          echo "Debug: USER after export: '$USER'"
          nix flake check --impure --no-build --all-systems

      - name: Quick test framework validation
        run: |
          export USER=${USER:-ci}
          echo "ğŸ§ª Validating NixTest framework"
          nix build --impure .#framework-check --verbose
          echo "âœ… Test framework validation passed"

  # Core build stage (2-4 minutes) - Only essential platforms
  build-core:
    name: Build ${{ matrix.name }}
    needs: validate
    if: (github.event.pull_request.draft != true) || (github.ref == 'refs/heads/main')
    strategy:
      fail-fast: false
      matrix:
        include:
          # Temporarily disabled due to GitHub Actions macOS ARM64 runner issues
          # - name: "Darwin ARM64"
          #   system: aarch64-darwin
          #   os: macos-14
          #   build_type: full
          - name: 'Linux x64'
            system: x86_64-linux
            os: ubuntu-latest
            build_type: full
          - name: 'Darwin x64'
            system: x86_64-darwin
            os: macos-13
            build_type: validate
    runs-on: ${{ matrix.os }}
    continue-on-error: ${{ matrix.name == 'Darwin ARM64' }} # Mark Darwin ARM64 as optional due to runner issues
    steps:
      - uses: actions/checkout@v4

      # Clean up any existing Nix installation on macOS with enhanced error handling
      - name: Clean existing Nix installation (macOS)
        if: runner.os == 'macOS'
        continue-on-error: true
        run: |
          echo "ğŸ§¹ Cleaning existing Nix installation..."

          # Enhanced cleanup with better error handling for GitHub Actions
          set +e  # Don't exit on error during cleanup

          # Stop services gracefully
          sudo launchctl stop org.nixos.nix-daemon 2>/dev/null || echo "Nix daemon not running"
          sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist 2>/dev/null || echo "Nix daemon plist not loaded"

          # Check if /nix exists and unmount if needed
          if mount | grep -q "/nix"; then
            echo "Unmounting /nix filesystem..."
            sudo umount /nix 2>/dev/null || echo "Failed to unmount /nix"
          fi

          # Remove Nix directories and configs with proper error handling
          if [[ -d "/nix" ]]; then
            echo "Removing /nix directory..."
            sudo rm -rf /nix 2>/dev/null || echo "Warning: Could not fully remove /nix"
          fi

          # Clean up configuration files
          sudo rm -f /etc/synthetic.conf 2>/dev/null || echo "No synthetic.conf to remove"
          sudo rm -f /Library/LaunchDaemons/org.nixos.* 2>/dev/null || echo "No Nix launch daemons to remove"
          sudo rm -rf /etc/nix 2>/dev/null || echo "No /etc/nix to remove"

          # Prepare synthetic.conf for fresh install
          echo "nix" | sudo tee /etc/synthetic.conf > /dev/null 2>&1 || echo "Warning: Could not create synthetic.conf"

          # Force filesystem sync before proceeding
          sync
          sleep 2

          echo "âœ… macOS cleanup completed (with error tolerance for CI)"
          set -e  # Re-enable exit on error

      - name: Install Nix with enhanced retry logic
        uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install
          enable_kvm: true
        env:
          # Enhanced environment for better compatibility
          ACTIONS_ALLOW_UNSECURE_COMMANDS: true

      # Phase 3: Enhanced multi-layer caching strategy
      - name: Cache Nix store (Phase 3 build optimization)
        uses: actions/cache@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
            ~/.cache/nix-index
            /tmp/nix-build-*
            ~/.local/state/nix
          key: phase3-build-${{ runner.os }}-${{ matrix.system }}-${{ hashFiles('flake.lock', 'flake.nix', 'hosts/**/*.nix') }}
          restore-keys: |
            phase3-build-${{ runner.os }}-${{ matrix.system }}-${{ hashFiles('flake.lock', 'flake.nix') }}-
            phase3-build-${{ runner.os }}-${{ matrix.system }}-
            phase3-validate-nix-${{ hashFiles('flake.lock') }}-${{ runner.os }}
            ${{ runner.os }}-${{ matrix.system }}-
            ${{ runner.os }}-nix-
            validate-nix-
          # Phase 3: Optimized cache settings
          enableCrossOsArchive: false
          save-always: true
          upload-chunk-size: 32768

      - name: Build configuration
        timeout-minutes: 90
        run: |
          export USER=${USER:-ci}
          echo "ğŸ—ï¸ Building ${{ matrix.name }} (${{ matrix.system }}) - Type: ${{ matrix.build_type }}"

          # Wait for Nix daemon to be fully ready
          echo "â³ Waiting for Nix daemon to be ready..."
          max_attempts=30
          attempt=0
          while ! nix --version >/dev/null 2>&1; do
            attempt=$((attempt + 1))
            if [[ $attempt -ge $max_attempts ]]; then
              echo "âŒ Nix daemon failed to start after $max_attempts attempts"
              exit 1
            fi
            echo "Attempt $attempt/$max_attempts: Waiting for Nix..."
            sleep 5
          done
          echo "âœ… Nix daemon is ready"

          # Show Nix configuration for debugging
          echo "ğŸ” Nix configuration:"
          nix --version
          echo "NIX_CONFIG: $NIX_CONFIG"

          case "${{ matrix.system }}" in
            *darwin*)
              if [[ "${{ matrix.build_type }}" == "full" ]]; then
                echo "Running full Darwin build..."
                nix build --impure --no-link .#darwinConfigurations.${{ matrix.system }}.system --verbose
              else
                echo "Running Darwin validation..."
                # More robust validation with better error handling
                nix eval --impure .#darwinConfigurations.${{ matrix.system }}.system --json --show-trace >/dev/null
              fi
              ;;
            *linux*)
              echo "Running NixOS validation..."
              nix eval --impure .#nixosConfigurations.${{ matrix.system }}.config.system.name --json --show-trace >/dev/null
              ;;
          esac
          echo "âœ… Build completed successfully"

  # Parallel test stage (2-3 minutes) with coverage support and cross-platform matrix
  test-parallel:
    name: Test ${{ matrix.category }} (${{ matrix.os-name }})
    needs: [validate, build-core]
    if: (github.event.pull_request.draft != true) || (github.ref == 'refs/heads/main')
    strategy:
      fail-fast: false
      matrix:
        include:
          # Unit tests - Cross-platform
          - category: unit
            test_target: 'lib-functions platform-detection framework-check'
            coverage: true
            os: macos-14
            os-name: 'macOS-ARM64'
          - category: unit
            test_target: 'lib-functions platform-detection framework-check'
            coverage: true
            os: ubuntu-latest
            os-name: 'Linux-x64'
          # Integration tests - Cross-platform
          - category: integration
            test_target: 'module-interaction cross-platform system-configuration'
            coverage: true
            os: macos-14
            os-name: 'macOS-ARM64'
          - category: integration
            test_target: 'module-interaction cross-platform system-configuration'
            coverage: false # Disable coverage on Linux to reduce CI time
            os: ubuntu-latest
            os-name: 'Linux-x64'
          # E2E tests - Primary platform only for speed
          - category: e2e
            test_target: 'all'
            coverage: false
            os: macos-14
            os-name: 'macOS-ARM64'
          # Performance benchmarks - Primary platform only
          - category: performance
            test_target: 'performance-benchmarks'
            coverage: false
            os: macos-14
            os-name: 'macOS-ARM64'
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      # Clean up any existing Nix installation (cross-platform)
      - name: Clean existing Nix installation (${{ matrix.os-name }})
        run: |
          echo "ğŸ§¹ Cleaning existing Nix installation for tests on ${{ matrix.os-name }}..."

          if [[ "${{ runner.os }}" == "macOS" ]]; then
            # macOS cleanup
            sudo launchctl stop org.nixos.nix-daemon 2>/dev/null || true
            sudo launchctl unload /Library/LaunchDaemons/org.nixos.nix-daemon.plist 2>/dev/null || true
            sudo umount /nix 2>/dev/null || true
            sudo rm -rf /nix 2>/dev/null || true
            sudo rm -f /etc/synthetic.conf /Library/LaunchDaemons/org.nixos.* 2>/dev/null || true
            echo "nix" | sudo tee /etc/synthetic.conf > /dev/null 2>&1 || true
            echo "âœ… macOS cleanup completed"
          else
            # Linux cleanup
            sudo systemctl stop nix-daemon.service 2>/dev/null || true
            sudo rm -rf /nix 2>/dev/null || true
            sudo rm -f /etc/systemd/system/nix-daemon.* 2>/dev/null || true
            echo "âœ… Linux cleanup completed"
          fi

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      # Phase 3: Advanced test cache with predictive restoration
      - name: Restore Nix cache (Phase 3 test optimization)
        uses: actions/cache/restore@v4
        continue-on-error: true
        with:
          path: |
            /nix/store
            ~/.cache/nix
            ~/.cache/nix-index
            /tmp/nix-build-*
            ~/.local/state/nix
            tests/.test-cache
            tests/performance/.perf-cache
          key: phase3-test-${{ runner.os }}-${{ matrix.category }}-${{ hashFiles('flake.lock', 'tests/**/*.nix', 'lib/**/*.nix') }}
          restore-keys: |
            phase3-test-${{ runner.os }}-${{ matrix.category }}-${{ hashFiles('flake.lock') }}-
            phase3-test-${{ runner.os }}-${{ matrix.category }}-
            phase3-build-${{ runner.os }}-aarch64-darwin-
            macOS-aarch64-darwin-
            validate-nix-
          # Phase 3: Performance-optimized settings
          enableCrossOsArchive: false
          fail-on-cache-miss: false

      # Phase 3: Enhanced failure recovery and retry mechanism
      - name: Run tests (Phase 3 with intelligent retry)
        timeout-minutes: 25 # Reduced due to Phase 3 optimizations
        run: |
          export USER=${USER:-ci}

          # Phase 3: Create cache directories
          mkdir -p tests/.test-cache tests/performance/.perf-cache

          # Phase 3: Test execution with failure recovery
          test_category="${{ matrix.category }}"
          max_retries=2
          retry_count=0

          run_test_with_recovery() {
            local category="$1"
            local attempt="$2"

            echo "ğŸ§ª Attempting $category tests (attempt $((attempt + 1))/$((max_retries + 1)))"

            # Phase 3: Memory optimization
            if [[ "$attempt" -gt 0 ]]; then
              echo "ğŸ§¹ Clearing caches for retry..."
              rm -rf /tmp/nix-build-* ~/.cache/nix/eval-cache-v* 2>/dev/null || true
              # Force garbage collection on retry
              nix-collect-garbage -d || true
            fi

            # Phase 3: Set optimization level based on attempt
            local opt_level="ultimate"
            if [[ "$attempt" -gt 0 ]]; then
              opt_level="aggressive"  # Fallback to safer mode on retry
            fi

            export PERFORMANCE_OPTIMIZATION_LEVEL="$opt_level"
            export PERFORMANCE_MEMORY_POOLING=true
            export PERFORMANCE_CACHE_STRATEGY="intelligent"

            return 0  # Success placeholder - actual test execution follows
          }

          # Nix í™˜ê²½ ì´ˆê¸°í™” (CIì—ì„œ PATH ì„¤ì •)
          if [[ -e /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh ]]; then
            source /nix/var/nix/profiles/default/etc/profile.d/nix-daemon.sh
          fi

          # Nix ë„êµ¬ë“¤ì´ PATHì— ìˆëŠ”ì§€ í™•ì¸
          if ! command -v nix-instantiate >/dev/null 2>&1; then
            echo "âš ï¸ nix-instantiate not found in PATH"
            echo "PATH: $PATH"
            echo "Available nix commands:"
            which nix || echo "nix not found"
            find /nix -name "nix-instantiate" 2>/dev/null || echo "nix-instantiate not found in /nix"
          else
            echo "âœ… nix-instantiate available"
          fi

          echo "ğŸ§ª Running ${{ matrix.category }} tests"
          echo "Debug: Current working directory: $(pwd)"
          echo "Debug: Available test files:"
          find tests -name "*${{ matrix.category }}*" || echo "No test files found"

          # Phase 3: Main test execution with intelligent retry
          while [[ $retry_count -le $max_retries ]]; do
            echo "ğŸ¯ Phase 3 Test Execution - Attempt $((retry_count + 1))"

            # Initialize recovery mechanism
            run_test_with_recovery "$test_category" "$retry_count"

            # Setup coverage collection directory
            mkdir -p coverage-reports test-reports

            # Phase 3: Execute tests with enhanced monitoring
            test_start_time=$(date +%s)
            exit_code=0

            case "${{ matrix.category }}" in
              "unit")
                echo "ğŸ§ª Running unit tests with NixTest framework"
                for target in ${{ matrix.test_target }}; do
                  echo "Running test target: $target"
                  nix build --impure .#$target 2>&1 | tee -a test-output.log || exit_code=$?
                  if [[ $exit_code -ne 0 ]]; then break; fi
                done
                ;;
              "integration")
                echo "ğŸ”— Running integration tests"
                for target in ${{ matrix.test_target }}; do
                  echo "Running integration target: $target"
                  nix build --impure .#$target 2>&1 | tee -a test-output.log || exit_code=$?
                  if [[ $exit_code -ne 0 ]]; then break; fi
                done
                ;;
              "e2e")
                echo "ğŸ¯ Running end-to-end tests"
                nix build --impure .#tests.all 2>&1 | tee test-output.log || exit_code=$?
                ;;
              "performance")
                echo "ğŸ“Š Running performance benchmarks"
                if nix build --impure .#performance-benchmarks 2>&1 | tee test-output.log; then
                  echo "âœ… Performance benchmarks completed"
                else
                  echo "âš ï¸ Performance benchmarks not available, skipping..."
                  exit_code=0  # Don't fail CI if performance tests are optional
                fi
                ;;
            esac

            test_end_time=$(date +%s)
            test_duration=$((test_end_time - test_start_time))

            echo "â±ï¸ Test execution time: ${test_duration}s"
            echo "ğŸ“Š Exit code: $exit_code"

            # Phase 3: Success condition check
            if [[ $exit_code -eq 0 ]]; then
              echo "âœ… Tests passed successfully on attempt $((retry_count + 1))"

              # Show performance summary
              if [[ -f test-output.log ]]; then
                echo "=== Phase 3 Performance Summary ==="
                grep -E "(Performance|efficiency|duration|memory)" test-output.log | tail -10 || true
              fi

              break
            fi

            # Phase 3: Failure analysis and retry logic
            retry_count=$((retry_count + 1))

            if [[ $retry_count -le $max_retries ]]; then
              echo "âŒ Test failed (exit code: $exit_code), retrying..."
              echo "ğŸ” Failure analysis:"

              # Show relevant error information
              if [[ -f test-output.log ]]; then
                echo "=== Error Summary ==="
                tail -30 test-output.log | grep -E "(ERROR|FAIL|error:|failed)" || tail -15 test-output.log
              fi

              # Phase 3: Smart retry delay based on failure type
              if grep -q "memory\|Memory\|RAM" test-output.log 2>/dev/null; then
                echo "ğŸ§  Memory-related failure detected, clearing caches..."
                sleep 30  # Longer delay for memory issues
              elif grep -q "timeout\|Timeout" test-output.log 2>/dev/null; then
                echo "â° Timeout detected, reducing parallelism..."
                export PERFORMANCE_MAX_PARALLEL_JOBS=8
                sleep 15
              else
                echo "ğŸ”„ Generic failure, quick retry..."
                sleep 10
              fi
            else
              echo "âŒ All retry attempts exhausted, failing..."
              if [[ -f test-output.log ]]; then
                echo "=== Final Error Output ==="
                tail -50 test-output.log
              fi
            fi
          done

          exit $exit_code

      - name: Upload coverage reports
        if: matrix.coverage == true && (success() || failure())
        uses: actions/upload-artifact@v4
        with:
          name: coverage-${{ matrix.category }}-${{ github.run_number }}
          path: |
            coverage-reports/
            test-reports/
          retention-days: 30

      - name: Generate coverage summary
        if: matrix.coverage == true && (success() || failure())
        run: |
          echo "ğŸ“Š Coverage Summary for ${{ matrix.category }}"
          echo "=================================="

          # Check if coverage files exist
          if ls coverage-reports/*.json >/dev/null 2>&1; then
            echo "Coverage files found:"
            ls -la coverage-reports/

            # Generate basic coverage summary
            echo "Coverage data collected for ${{ matrix.category }} tests"
            echo "Files analyzed: $(ls coverage-reports/*.json | wc -l)"
          else
            echo "No coverage files found for ${{ matrix.category }}"
          fi

  # Smoke test for all PRs (30 seconds)
  smoke-test:
    name: Smoke Test
    needs: validate
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: cachix/install-nix-action@v27
        with:
          nix_path: nixpkgs=channel:nixos-unstable
          install_url: https://releases.nixos.org/nix/nix-2.18.8/install

      - name: Quick smoke test
        run: |
          export USER=${USER:-ci}
          nix flake check --impure --no-build --all-systems

          # Test that the new testing framework can be built
          echo "ğŸ§ª Testing new NixTest framework"
          nix build --impure .#framework-check --verbose
          echo "âœ… Smoke test passed - Draft PR validation complete"

  # Summary and status reporting
  ci-complete:
    name: CI Summary
    needs: [validate, build-core, test-parallel, smoke-test]
    runs-on: ubuntu-latest
    if: always() && !cancelled()
    # Force this job to run even if previous jobs fail
    continue-on-error: false
    steps:
      - name: Determine overall status
        id: status
        run: |
          validation_result="${{ needs.validate.result }}"
          build_result="${{ needs.build-core.result }}"
          test_result="${{ needs.test-parallel.result }}"
          smoke_result="${{ needs.smoke-test.result }}"

          echo "Debug: validation_result=$validation_result"
          echo "Debug: build_result=$build_result"
          echo "Debug: test_result=$test_result"
          echo "Debug: smoke_result=$smoke_result"
          echo "Debug: CI_MODE=$CI_MODE"
          echo "Debug: github.event_name=${{ github.event_name }}"

          # Simplified status determination logic
          if [[ "$validation_result" != "success" ]]; then
            echo "status=failed" >> $GITHUB_OUTPUT
            echo "message=Validation failed" >> $GITHUB_OUTPUT
          elif [[ "$CI_MODE" == "draft" ]]; then
            if [[ "$smoke_result" == "success" ]]; then
              echo "status=success" >> $GITHUB_OUTPUT
              echo "message=Draft PR validation passed (smoke test only)" >> $GITHUB_OUTPUT
            else
              echo "status=failed" >> $GITHUB_OUTPUT
              echo "message=Draft PR smoke test failed" >> $GITHUB_OUTPUT
            fi
          else
            # For main branch (push events), smoke test is skipped
            if [[ "${{ github.event_name }}" == "push" ]]; then
              if [[ "$build_result" == "success" && ("$test_result" == "success" || "$test_result" == "skipped") ]]; then
                echo "status=success" >> $GITHUB_OUTPUT
                echo "message=Full CI pipeline completed successfully" >> $GITHUB_OUTPUT
              else
                echo "status=failed" >> $GITHUB_OUTPUT
                echo "message=Build or test stage failed (build: $build_result, test: $test_result)" >> $GITHUB_OUTPUT
              fi
            else
              # For PR events, include smoke test
              if [[ "$build_result" == "success" && ("$test_result" == "success" || "$test_result" == "skipped") && "$smoke_result" == "success" ]]; then
                echo "status=success" >> $GITHUB_OUTPUT
                echo "message=Full CI pipeline completed successfully" >> $GITHUB_OUTPUT
              else
                echo "status=failed" >> $GITHUB_OUTPUT
                echo "message=Build, test, or smoke test stage failed (build: $build_result, test: $test_result, smoke: $smoke_result)" >> $GITHUB_OUTPUT
              fi
            fi
          fi

      - name: Comment on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Helper functions for cleaner code
              function getStatusIcon(result) {
                return result === 'success' ? 'âœ…' : 'âŒ';
              }

              function buildTemplate(isDraft, statusIcon, message, icons, footer) {
                const efficiency = isDraft ? 'âš¡ **Ultra Fast** (smoke test only)' : 'ğŸš€ **Streamlined** (parallel execution)';
                const buildStatus = isDraft ? 'â­ï¸ Skipped (draft)' : icons.build + ' Core platforms';
                const testStatus = isDraft ? 'â­ï¸ Skipped (draft)' : icons.test + ' Parallel execution';

                return '## ' + statusIcon + ' Streamlined CI Results\n\n' +
                  efficiency + '\n\n' +
                  '**Status**: ' + message + '\n\n' +
                  '**Pipeline Summary**:\n' +
                  '- **Validation**: ' + icons.validation + ' Lint & flake check\n' +
                  '- **Build**: ' + buildStatus + '\n' +
                  '- **Tests**: ' + testStatus + '\n' +
                  '- **Smoke Test**: ' + icons.smoke + ' Quick validation\n\n' +
                  footer;
              }

              // Main logic
              const status = '${{ steps.status.outputs.status }}';
              const message = '${{ steps.status.outputs.message }}';
              const isDraft = '${{ env.CI_MODE }}' === 'draft';

              const statusIcon = getStatusIcon(status);
              const icons = {
                validation: getStatusIcon('${{ needs.validate.result }}'),
                build: getStatusIcon('${{ needs.build-core.result }}'),
                test: getStatusIcon('${{ needs.test-parallel.result }}'),
                smoke: getStatusIcon('${{ needs.smoke-test.result }}')
              };

              const footer = isDraft ? '_ğŸ’¡ Mark as ready to run full CI pipeline_' : '_ğŸ¯ Optimized for speed: ~5-8 minutes total_';
              const template = buildTemplate(isDraft, statusIcon, message, icons, footer);

              // Find and update existing comment
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });

              const existingComment = comments.find(comment =>
                comment.user.type === 'Bot' && comment.body.includes('Streamlined CI Results')
              );

              if (existingComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existingComment.id,
                  body: template
                });
                console.log('Updated existing CI comment');
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: template
                });
                console.log('Created new CI comment');
              }
            } catch (error) {
              console.error('Failed to update PR comment:', error);
              // Continue workflow even if comment fails
            }

      - name: Report CI status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          status="${{ steps.status.outputs.status }}"
          message="${{ steps.status.outputs.message }}"
          state=$([ "$status" = "success" ] && echo "success" || echo "failure")

          echo "ğŸ” Setting CI status: $state - $message"
          echo "ğŸ“ SHA: ${{ github.sha }}"
          echo "ğŸ”— Run ID: ${{ github.run_id }}"

          # Primary attempt: Use gh CLI
          if gh api repos/baleen37/dotfiles/statuses/${{ github.sha }} \
            -X POST \
            -f state="$state" \
            -f description="$message" \
            -f context="CI" \
            -f target_url="https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}" \
            --verbose; then
            echo "âœ… CI status reported successfully via gh CLI"
          else
            echo "âš ï¸ gh CLI failed, trying curl fallback..."

            # Fallback: Use curl directly
            curl -X POST \
              -H "Authorization: token $GITHUB_TOKEN" \
              -H "Accept: application/vnd.github.v3+json" \
              -d "{\"state\":\"$state\",\"description\":\"$message\",\"context\":\"CI\",\"target_url\":\"https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}\"}" \
              https://api.github.com/repos/baleen37/dotfiles/statuses/${{ github.sha }}

            echo "âœ… CI status reported via curl fallback"
          fi

          # Verify the status was set
          echo "ğŸ” Verifying CI status was set..."
          gh api repos/baleen37/dotfiles/commits/${{ github.sha }}/statuses --jq '.[] | select(.context == "CI") | {state: .state, description: .description}'

      - name: Final status check
        run: |
          status="${{ steps.status.outputs.status }}"
          message="${{ steps.status.outputs.message }}"

          if [[ "$status" != "success" ]]; then
            echo "âŒ CI pipeline failed: $message"
            exit 1
          else
            echo "âœ… CI pipeline succeeded: $message"
          fi

  # Fallback job in case ci-complete fails
  ci-status-fallback:
    name: CI Status Fallback
    needs: [validate, build-core, test-parallel, smoke-test]
    runs-on: ubuntu-latest
    if: always() && !cancelled() && (failure() || needs.ci-complete.result == 'failure')
    steps:
      - name: Emergency CI Status
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸš¨ CI Summary job failed, setting emergency status"

          # Always report failure if we reach this point
          curl -X POST \
            -H "Authorization: token $GITHUB_TOKEN" \
            -H "Accept: application/vnd.github.v3+json" \
            -d '{"state":"failure","description":"CI pipeline failed or incomplete","context":"CI","target_url":"https://github.com/baleen37/dotfiles/actions/runs/${{ github.run_id }}"}' \
            https://api.github.com/repos/baleen37/dotfiles/statuses/${{ github.sha }}

          echo "âœ… Emergency CI status set to failure"

  # Auto-merge for all PRs after successful CI
  auto-merge:
    name: Auto-merge PR
    needs: ci-complete
    runs-on: ubuntu-latest
    if: >
      needs.ci-complete.result == 'success' &&
      github.event_name == 'pull_request' &&
      !github.event.pull_request.draft
    permissions:
      contents: write
      pull-requests: write
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Auto-approve and enable auto-merge
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸš€ Auto-merging PR #${{ github.event.number }}"
          echo "Author: ${{ github.event.pull_request.user.login }}"

          # Check if author is repo owner
          author="${{ github.event.pull_request.user.login }}"
          repo_owner="${{ github.repository_owner }}"

          if [[ "$author" == "$repo_owner" ]]; then
            echo "ğŸ”§ Repo owner PR detected - GitHub prevents self-approval"
            echo "âœ… Relying on successful CI for merge qualification"
            echo "ğŸ¯ Branch protection allows admin bypass for repo owner"
          else
            echo "ğŸ‘¤ External contributor - auto-approving PR"
            # Auto-approve the PR for external contributors
            gh pr review ${{ github.event.number }} --approve \
              --body "âœ… **Auto-approved**: CI íŒŒì´í”„ë¼ì¸ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.

            - **ìƒíƒœ**: ëª¨ë“  í…ŒìŠ¤íŠ¸ í†µê³¼ âœ…
            - **ë¹Œë“œ**: ì„±ê³µ âœ…
            - **ê²€ì¦**: ì™„ë£Œ âœ…

            _ğŸ¤– ìë™í™”ëœ ìŠ¹ì¸ ë° ë¨¸ì§€ í”„ë¡œì„¸ìŠ¤_"
          fi

          # Enable auto-merge (works for both cases due to admin bypass)
          gh pr merge ${{ github.event.number }} --auto --squash

          echo "âœ… Auto-merge enabled for PR #${{ github.event.number }}"
          echo "PR will automatically merge when all conditions are met (including approvals)"

# PR #312 CI íŠ¸ë¦¬ê±° í™•ì¸ìš© ì£¼ì„
