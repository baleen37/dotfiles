# T017: ClaudeCodeConfig model - manages Claude Code configuration deployment
# Provides declarative configuration for Claude Code installation and setup

{ config, lib, pkgs, ... }:

with lib;

let
  cfg = config.programs.claude-code;

  # Platform detection
  isDarwin = pkgs.stdenv.hostPlatform.isDarwin;
  isLinux = pkgs.stdenv.hostPlatform.isLinux;

  # CI environment detection
  isCI = builtins.getEnv "CI" != "" ||
         builtins.getEnv "GITHUB_ACTIONS" != "" ||
         builtins.getEnv "NIXOS_CI" != "";

  # Platform-specific paths
  platformPaths = {
    darwin = {
      configBase = "/Users/${config.home.username}";
      systemConfigDir = "/etc/nix";
      homebrewPrefix = "/opt/homebrew";
      applicationSupport = "/Users/${config.home.username}/Library/Application Support";
    };
    nixos = {
      configBase = "/home/${config.home.username}";
      systemConfigDir = "/etc/nixos";
      homebrewPrefix = "/home/linuxbrew/.linuxbrew";
      userBin = "/home/${config.home.username}/.local/bin";
    };
  };

  # Get current platform paths
  currentPlatformPaths = if isDarwin then platformPaths.darwin else platformPaths.nixos;

  # Default Claude Code configuration
  defaultClaudeConfig = {
    commands = {
      plan = "Planning and architecture tasks";
      specify = "Specification and requirement gathering";
      tasks = "Task management and tracking";
      implement = "Implementation and development";
      constitution = "Configuration and governance";
    };

    settings = {
      theme = "dark";
      autoSave = true;
      enableLogging = true;
      logLevel = "info";
      timeout = 300;
      maxRetries = 3;
    };

    agents = {
      planner = {
        role = "planning";
        model = "claude-3-sonnet";
        temperature = 0.1;
      };
      implementer = {
        role = "implementation";
        model = "claude-3-sonnet";
        temperature = 0.3;
      };
    };
  };

  # Claude Code configuration generator
  claudeCodeConfigGenerator = {
    # Generate CLAUDE.md content
    generateClaudeMd = content: ''
      # CLAUDE.md - Project Configuration

      ## Project Overview
      ${content.overview or "Generated configuration"}

      ## Core Principles
      ${concatStringsSep "\n" (content.principles or [
        "- Follow TDD methodology"
        "- Maintain high code quality"
        "- Ensure comprehensive testing"
        "- Document all changes"
      ])}

      ## Configuration
      Auto-generated by Nix configuration on ${builtins.currentTime}
    '';

    # Generate settings.json content
    generateSettingsJson = settings: builtins.toJSON {
      inherit (settings) theme autoSave enableLogging logLevel timeout maxRetries;
      generatedAt = builtins.currentTime;
      nixManaged = true;
    };

    # Generate command files
    generateCommandFile = name: description: ''
      # ${name}

      ${description}

      ## Usage
      This command is managed by Nix configuration.

      ## Configuration
      - Auto-generated: true
      - Managed by: Home Manager
      - Last updated: ${builtins.currentTime}
    '';
  };

  # Configuration validation
  validateConfig = config:
    let
      requiredFields = [ "commands" "settings" "agents" ];
      hasRequiredFields = all (field: hasAttr field config) requiredFields;
    in
    if !hasRequiredFields then
      throw "Claude Code configuration missing required fields: ${toString requiredFields}"
    else
      config;

  # Merge configurations with defaults
  mergeConfigs = userConfig: recursiveUpdate defaultClaudeConfig userConfig;

  # Final configuration after validation and merging
  finalConfig = validateConfig (mergeConfigs cfg.configuration);

in
{
  # Configuration options
  options.programs.claude-code = {
    enable = mkOption {
      type = types.bool;
      default = !isCI;
      description = "Enable Claude Code configuration management (automatically disabled in CI environments)";
    };

    package = mkOption {
      type = types.package;
      default = pkgs.writeShellScriptBin "claude-code" ''
        echo "Claude Code configuration managed by Nix"
      '';
      description = "Claude Code package to use";
    };

    configuration = mkOption {
      type = types.attrs;
      default = { };
      description = "Claude Code configuration object";
      example = literalExpression ''
        {
          commands = {
            custom = "Custom command description";
          };
          settings = {
            theme = "light";
            timeout = 600;
          };
        }
      '';
    };

    configDirectory = mkOption {
      type = types.str;
      default = ".claude";
      description = "Directory name for Claude Code configuration";
    };

    enableSymlinks = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to create symlinks to dotfiles configuration";
    };

    forceOverwrite = mkOption {
      type = types.bool;
      default = true;
      description = "Whether to force overwrite existing configuration";
    };

    enableBackups = mkOption {
      type = types.bool;
      default = false;
      description = "Whether to create backup files (disabled by default)";
    };

    backupSuffix = mkOption {
      type = types.str;
      default = ".backup";
      description = "Suffix for backup files";
    };

    extraFiles = mkOption {
      type = types.attrsOf types.str;
      default = { };
      description = "Additional files to create in Claude Code directory";
      example = literalExpression ''
        {
          "custom.md" = "Custom configuration content";
          "scripts/helper.sh" = "#!/bin/bash\necho helper";
        }
      '';
    };

    deploymentHooks = mkOption {
      type = types.attrsOf types.str;
      default = { };
      description = "Shell commands to run during deployment phases";
      example = literalExpression ''
        {
          pre = "echo 'Preparing Claude Code deployment'";
          post = "echo 'Claude Code deployment complete'";
          cleanup = "echo 'Cleaning up temporary files'";
        }
      '';
    };

    shell = mkOption {
      type = types.submodule {
        options = {
          aliases = mkOption {
            type = types.attrsOf types.str;
            default = {
              cc = "claude --dangerously-skip-permissions";
            };
            description = "Claude CLI shell aliases";
          };

          integration = mkOption {
            type = types.bool;
            default = true;
            description = "Enable shell integration features";
          };
        };
      };
      default = { };
      description = "Shell integration configuration";
    };

    symlinks = mkOption {
      type = types.submodule {
        options = {
          enable = mkOption {
            type = types.bool;
            default = true;
            description = "Enable symlink management for Claude configuration";
          };

          sourceDir = mkOption {
            type = types.str;
            default = "modules/shared/config/claude";
            description = "Source directory for Claude configuration files";
          };

          fallbackSources = mkOption {
            type = types.listOf types.str;
            default = [
              "dev/dotfiles/modules/shared/config/claude"
              "./modules/shared/config/claude"
            ];
            description = "Fallback source directories";
          };

          preserveBrokenLinks = mkOption {
            type = types.bool;
            default = false;
            description = "Whether to preserve broken symlinks during cleanup";
          };
        };
      };
      default = { };
      description = "Symlink management configuration";
    };
  };

  # Module configuration
  config = mkIf cfg.enable {
    # Add claude-code package to user packages
    home.packages = [ cfg.package ];

    # Environment variables for Claude Code
    home.sessionVariables = {
      CLAUDE_CODE_CONFIG_DIR = "${config.home.homeDirectory}/${cfg.configDirectory}";
      CLAUDE_CODE_NIX_MANAGED = "true";
      CLAUDE_CODE_PLATFORM = if isDarwin then "darwin" else "nixos";
      CLAUDE_CODE_CONFIG_BASE = currentPlatformPaths.configBase;
      CLAUDE_CODE_SYSTEM_CONFIG = currentPlatformPaths.systemConfigDir;
      CLAUDE_CODE_SHELL_INTEGRATION = if cfg.shell.integration then "enabled" else "disabled";
    } // (optionalAttrs isDarwin {
      CLAUDE_CODE_HOMEBREW_PREFIX = currentPlatformPaths.homebrewPrefix;
      CLAUDE_CODE_APP_SUPPORT = currentPlatformPaths.applicationSupport;
    }) // (optionalAttrs isLinux {
      CLAUDE_CODE_USER_BIN = currentPlatformPaths.userBin;
    });

    # Shell aliases integration (only when shell integration is enabled)
    programs.zsh.shellAliases = mkIf cfg.shell.integration cfg.shell.aliases;

    # Symlink activation script (integrated from claude-activation.nix)
    home.activation.claudeCodeSymlinks = mkIf cfg.symlinks.enable (lib.hm.dag.entryAfter [ "writeBoundary" ] ''
      set -euo pipefail

      CLAUDE_DIR="${config.home.homeDirectory}/${cfg.configDirectory}"
      SOURCE_DIR="${config.home.homeDirectory}/${cfg.symlinks.sourceDir}"
      FALLBACK_SOURCES=(${lib.concatStringsSep " " (map (s: "\"${config.home.homeDirectory}/${s}\"") cfg.symlinks.fallbackSources)})

      echo "=== Claude Code 설정 심볼릭 링크 업데이트 시작 ==="
      echo "Claude 디렉토리: $CLAUDE_DIR"
      echo "기본 소스 디렉토리: $SOURCE_DIR"
      echo "플랫폼: ${if isDarwin then "darwin" else "nixos"}"

      # 소스 디렉토리 유효성 검사 및 fallback
      ACTUAL_SOURCE_DIR=""

      if [[ -d "$SOURCE_DIR" ]]; then
        ACTUAL_SOURCE_DIR="$SOURCE_DIR"
        echo "✓ 기본 소스 디렉토리 확인됨: $SOURCE_DIR"
      else
        echo "⚠ 기본 소스 디렉토리 없음: $SOURCE_DIR"
        echo "Fallback 디렉토리들 확인 중..."

        for fallback_dir in "''${FALLBACK_SOURCES[@]}"; do
          echo "  시도 중: $fallback_dir"
          if [[ -d "$fallback_dir" ]]; then
            ACTUAL_SOURCE_DIR="$fallback_dir"
            echo "  ✓ Fallback 소스 발견: $fallback_dir"
            break
          fi
        done

        if [[ -z "$ACTUAL_SOURCE_DIR" ]]; then
          echo "❌ 오류: Claude 설정 소스 디렉토리를 찾을 수 없습니다!"
          echo "확인한 경로들:"
          echo "  - $SOURCE_DIR"
          for fallback_dir in "''${FALLBACK_SOURCES[@]}"; do
            echo "  - $fallback_dir"
          done
          echo ""
          echo "해결 방법:"
          echo "1. dotfiles를 올바른 위치에 clone했는지 확인"
          echo "2. 'make build' 또는 'make switch' 실행"
          echo "3. Nix flake가 올바르게 설정되었는지 확인"
          exit 1
        fi
      fi

      echo "사용할 소스 디렉토리: $ACTUAL_SOURCE_DIR"

      # Claude 디렉토리 생성
      mkdir -p "$CLAUDE_DIR"

      # 기존 개별 파일 심볼릭 링크들과 .new, .update-notice 파일들 정리
      echo "기존 설정 파일들 정리..."
      rm -f "$CLAUDE_DIR"/*.new "$CLAUDE_DIR"/*.update-notice "$CLAUDE_DIR"/*.bak

      # 폴더 심볼릭 링크 생성 함수
      create_folder_symlink() {
        local source_folder="$1"
        local target_folder="$2"
        local folder_name=$(basename "$source_folder")

        echo "처리 중: $folder_name/"

        if [[ ! -d "$source_folder" ]]; then
          echo "  소스 폴더 없음, 건너뜀"
          return 0
        fi

        # 기존 폴더나 링크가 있으면 제거
        if [[ -e "$target_folder" || -L "$target_folder" ]]; then
          echo "  기존 $folder_name 폴더/링크 제거"
          rm -rf "$target_folder"
        fi

        # 폴더 심볼릭 링크 생성
        ln -sf "$source_folder" "$target_folder"
        echo "  폴더 심볼릭 링크 생성: $target_folder -> $source_folder"
      }

      # 개별 파일 심볼릭 링크 생성 함수
      create_file_symlink() {
        local source_file="$1"
        local target_file="$2"
        local file_name=$(basename "$source_file")

        echo "처리 중: $file_name"

        if [[ ! -f "$source_file" ]]; then
          echo "  소스 파일 없음, 건너뜀"
          return 0
        fi

        # 기존 파일이나 링크가 있으면 제거
        if [[ -e "$target_file" || -L "$target_file" ]]; then
          rm -f "$target_file"
        fi

        # 심볼릭 링크 생성
        ln -sf "$source_file" "$target_file"
        echo "  파일 심볼릭 링크 생성: $target_file -> $source_file"
      }

      echo ""
      echo "=== Claude 설정 심볼릭 링크 생성 ==="

      # 1. 폴더 단위 심볼릭 링크 생성
      create_folder_symlink "$ACTUAL_SOURCE_DIR/commands" "$CLAUDE_DIR/commands"
      create_folder_symlink "$ACTUAL_SOURCE_DIR/agents" "$CLAUDE_DIR/agents"
      create_folder_symlink "$ACTUAL_SOURCE_DIR/hooks" "$CLAUDE_DIR/hooks"

      # 2. 루트 레벨 설정 파일들 (.md, .json)
      for source_file in "$ACTUAL_SOURCE_DIR"/*.md "$ACTUAL_SOURCE_DIR"/*.json; do
        if [[ -f "$source_file" ]]; then
          file_name=$(basename "$source_file")
          create_file_symlink "$source_file" "$CLAUDE_DIR/$file_name"
        fi
      done

      # 끊어진 심볼릭 링크 정리 (preserveBrokenLinks가 false일 때만)
      ${optionalString (!cfg.symlinks.preserveBrokenLinks) ''
      find "$CLAUDE_DIR" -maxdepth 1 -type l | while read -r link_file; do
        if [[ ! -e "$link_file" ]]; then
          echo "  끊어진 링크 삭제: $(basename "$link_file")"
          rm -f "$link_file"
        fi
      done
      ''}

      echo ""
      echo "✅ Claude Code 설정 심볼릭 링크 생성 완료!"
      echo "=== Claude Code 설정 심볼릭 링크 업데이트 완료 ==="
    '');

    # Assertions for configuration validation
    assertions = [
      {
        assertion = cfg.enableBackups -> (cfg.backupSuffix != "");
        message = "backup suffix cannot be empty when backups are enabled";
      }
      {
        assertion = cfg.configDirectory != "";
        message = "config directory cannot be empty";
      }
      {
        assertion = !(cfg.enableBackups && cfg.forceOverwrite);
        message = "backups and force overwrite are mutually exclusive";
      }
    ];

    # Warning for backup files (should be disabled)
    warnings = optional cfg.enableBackups
      "Claude Code backup files are enabled. This may create unwanted backup files.";
  };

  # Internal module utilities (not exported to Home Manager)
  # Note: Removed meta export to prevent Home Manager configuration conflicts
}
