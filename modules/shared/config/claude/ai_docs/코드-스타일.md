# 코드 스타일 가이드

## 기본 원칙

### 1. 일관성 우선 (Consistency First)
- **기존 패턴 유지**: 새로운 코드는 기존 코드 스타일과 일치
- **파일 내 일관성**: 같은 파일 내에서는 완전히 동일한 스타일 사용
- **프로젝트 전체 일관성**: 프로젝트 전반에 걸쳐 일관된 패턴 유지

### 2. 가독성 중시 (Readability Focused)
- **명확한 네이밍**: 변수, 함수, 파일명은 목적을 명확히 표현
- **적절한 주석**: 복잡한 로직에는 의도를 설명하는 주석 추가
- **구조적 명확성**: 코드의 구조와 흐름이 명확하게 보이도록 작성

### 3. 단순성 추구 (Simplicity Preferred)
- **복잡한 로직 분해**: 복잡한 로직은 작은 함수로 분해
- **명시적 표현**: 암시적이거나 트릭을 사용하는 코드 지양
- **필요한 것만**: 불필요한 추상화나 복잡성 추가 금지

## 언어별 스타일 가이드

### Nix 코드 스타일

#### 파일 구조
```nix
# 표준 헤더
{ config, lib, pkgs, ... }:

# let 바인딩 (필요한 경우)
let
  # 로컬 변수는 camelCase
  customPackage = pkgs.package.override {
    # 설정 옵션들
  };
in
{
  # 메인 설정
  imports = [
    # 임포트 목록
  ];

  # 옵션 정의
  options = {
    # 옵션들
  };

  # 설정 구현
  config = {
    # 실제 설정들
  };
}
```

#### 네이밍 규칙
```nix
# 변수명: camelCase
let
  myVariable = "value";
  customPackage = pkgs.hello;
in

# 속성명: kebab-case (Nix 관례)
{
  services.my-service = {
    enable = true;
    custom-option = "value";
  };

  # 파일명: kebab-case
  # development-tools.nix
  # system-settings.nix
}
```

#### 들여쓰기 및 포맷팅
```nix
# 2칸 들여쓰기
{
  services.example = {
    enable = true;
    settings = {
      option1 = "value1";
      option2 = "value2";
    };
  };

  # 긴 목록은 한 줄에 하나씩
  environment.systemPackages = with pkgs; [
    git
    vim
    curl
    wget
  ];

  # 조건부 설정
  environment.systemPackages = with pkgs; [
    # 기본 패키지
    git
    vim
  ] ++ lib.optionals stdenv.isDarwin [
    # macOS 전용
    mas
  ];
}
```

### Shell 스크립트 스타일

#### 스크립트 헤더
```bash
#!/usr/bin/env bash
# 스크립트 설명
# 사용법: ./script.sh [옵션]

set -euo pipefail  # 엄격한 에러 처리
```

#### 변수 및 함수
```bash
# 변수명: UPPER_CASE (상수), lower_case (지역 변수)
readonly SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly CONFIG_FILE="$SCRIPT_DIR/config.sh"

# 함수명: snake_case
function check_dependencies() {
    local required_commands=("git" "nix" "curl")

    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &> /dev/null; then
            echo "Error: $cmd is required but not installed." >&2
            return 1
        fi
    done
}
```

#### 에러 처리
```bash
# 에러 메시지는 stderr로
echo "Error: Something went wrong" >&2

# 종료 코드 사용
exit 1  # 실패
exit 0  # 성공

# 조건부 실행
if ! command -v git &> /dev/null; then
    echo "Git is not installed" >&2
    exit 1
fi
```

### Python 스크립트 스타일

#### 기본 구조
```python
#!/usr/bin/env python3
"""
스크립트 설명

사용법:
    python script.py [options]
"""

import sys
import os
from pathlib import Path

def main():
    """메인 함수"""
    pass

if __name__ == "__main__":
    main()
```

#### 네이밍 규칙
```python
# 함수: snake_case
def check_system_status():
    pass

# 클래스: PascalCase
class SystemManager:
    def __init__(self):
        pass

# 상수: UPPER_CASE
CONFIG_PATH = Path.home() / ".config" / "app"

# 변수: snake_case
system_status = "active"
```

## 설정 파일 스타일

### JSON 설정
```json
{
  "version": "1.0.0",
  "settings": {
    "enable_feature": true,
    "max_connections": 100,
    "timeout_seconds": 30
  },
  "paths": {
    "config_dir": "/etc/myapp",
    "log_dir": "/var/log/myapp"
  }
}
```

### YAML 설정
```yaml
version: "1.0.0"

settings:
  enable_feature: true
  max_connections: 100
  timeout_seconds: 30

paths:
  config_dir: /etc/myapp
  log_dir: /var/log/myapp

# 리스트 형태
packages:
  - git
  - vim
  - curl
```

## 파일 구조 규칙

### 디렉토리 구조
```
project/
├── modules/           # 기능별 모듈
│   ├── shared/       # 공통 설정
│   ├── darwin/       # macOS 특화
│   └── linux/        # Linux 특화
├── scripts/          # 실행 스크립트
├── docs/             # 문서
└── tests/            # 테스트 파일
```

### 파일 네이밍
```
# Nix 파일: kebab-case
development-tools.nix
system-settings.nix
homebrew-packages.nix

# 스크립트: kebab-case
build-switch.sh
check-config.sh
test-system.sh

# 문서: kebab-case
installation-guide.md
troubleshooting.md
```

## 주석 및 문서화

### 코드 주석
```nix
# 단일 행 주석: 코드 의도 설명
{
  # macOS 시스템 기본값 설정
  system.defaults = {
    # Dock 자동 숨기기 활성화
    dock.autohide = true;

    # Finder에서 모든 파일 확장자 표시
    finder.AppleShowAllExtensions = true;
  };

  # 복잡한 로직에는 블록 주석 사용
  # 이 설정은 다음과 같은 이유로 필요함:
  # 1. 보안 강화
  # 2. 사용자 경험 개선
  # 3. 시스템 성능 최적화
  services.security = {
    enable = true;
  };
}
```

### 함수 문서화
```bash
# 함수 설명
# 인자: $1 - 설정 파일 경로
# 반환: 0 (성공), 1 (실패)
# 사용법: validate_config "/path/to/config"
function validate_config() {
    local config_file="$1"

    # 파일 존재 확인
    if [[ ! -f "$config_file" ]]; then
        echo "Config file not found: $config_file" >&2
        return 1
    fi

    # 설정 검증 로직
    # ...
}
```

## 에러 처리 및 로깅

### 에러 메시지
```bash
# 일관된 에러 메시지 형식
echo "ERROR: [$(date +'%Y-%m-%d %H:%M:%S')] $error_message" >&2

# 컨텍스트 정보 포함
echo "ERROR: Failed to build configuration" >&2
echo "  File: $config_file" >&2
echo "  Line: $line_number" >&2
echo "  Details: $error_details" >&2
```

### 로그 레벨
```bash
# 로그 레벨 정의
readonly LOG_LEVEL_ERROR=1
readonly LOG_LEVEL_WARN=2
readonly LOG_LEVEL_INFO=3
readonly LOG_LEVEL_DEBUG=4

function log_error() {
    echo "ERROR: $*" >&2
}

function log_warn() {
    echo "WARN: $*" >&2
}

function log_info() {
    echo "INFO: $*"
}
```

## 성능 고려사항

### 효율적인 코드 작성
```nix
# 좋은 예: 조건부 임포트
{
  imports = [
    ./base.nix
  ] ++ lib.optionals config.features.development [
    ./development.nix
  ];

  # 나쁜 예: 항상 모든 모듈 임포트
  # imports = [
  #   ./base.nix
  #   ./development.nix  # 항상 로드됨
  # ];
}
```

### 리소스 사용 최적화
```bash
# 좋은 예: 병렬 처리
for file in *.txt; do
    process_file "$file" &
done
wait

# 나쁜 예: 순차 처리
for file in *.txt; do
    process_file "$file"
done
```

## 보안 고려사항

### 안전한 코드 작성
```bash
# 안전한 임시 파일 생성
temp_file=$(mktemp)
trap 'rm -f "$temp_file"' EXIT

# 안전한 경로 처리
config_dir="${XDG_CONFIG_HOME:-$HOME/.config}"
mkdir -p "$config_dir"

# 권한 설정
chmod 600 "$config_file"  # 소유자만 읽기/쓰기
```

### 민감한 정보 처리
```bash
# 환경 변수에서 민감한 정보 읽기
readonly API_KEY="${API_KEY:-}"
if [[ -z "$API_KEY" ]]; then
    echo "ERROR: API_KEY environment variable is required" >&2
    exit 1
fi

# 로그에 민감한 정보 출력 금지
log_info "Authenticating with API..."  # 키 값은 로그에 출력하지 않음
```

---

*코드 스타일의 일관성은 프로젝트의 유지보수성과 협업 효율성을 크게 향상시킵니다.*
