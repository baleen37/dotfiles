#!/usr/bin/env bash
# Refactor rollback script for safely restoring NixOS/Darwin configurations
# Part of PHASE0-002: Create backup and rollback system

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Default values
BACKUP_DIR="${HOME}/.dotfiles-backups"
VERBOSE=false
DRY_RUN=false

usage() {
    cat << EOF
Usage: $0 <command> [options]

Commands:
    restore     Restore from a backup
    status      Show current system status vs backup
    list        List available backups for restore

Options:
    --backup DIR        Backup directory to restore from
    --dry-run          Show what would be restored without making changes
    --force            Skip confirmation prompts
    --verbose          Enable verbose output
    --help             Show this help

Examples:
    $0 restore --backup ~/.dotfiles-backups/backup_20240106_143022
    $0 restore --backup /path/to/backup --dry-run
    $0 status --backup ~/.dotfiles-backups/backup_20240106_143022
    $0 list
EOF
}

log() {
    if [[ "$VERBOSE" == true ]]; then
        echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" >&2
    fi
}

error() {
    echo "ERROR: $*" >&2
    exit 1
}

confirm() {
    local message="$1"
    local force="${2:-false}"

    if [[ "$force" == true ]]; then
        log "Skipping confirmation (force mode): $message"
        return 0
    fi

    echo -n "$message (y/N): "
    read -r response
    case "$response" in
        [yY]|[yY][eE][sS])
            return 0
            ;;
        *)
            echo "Operation cancelled."
            exit 1
            ;;
    esac
}

validate_backup() {
    local backup_path="$1"

    log "Validating backup at $backup_path"

    # Check if backup directory exists
    [[ -d "$backup_path" ]] || error "Backup directory does not exist: $backup_path"

    # Check for required files
    local required_files=("flake.nix" "flake.lock" "backup_metadata.json")
    for file in "${required_files[@]}"; do
        [[ -f "$backup_path/$file" ]] || error "Missing required file in backup: $file"
    done

    # Check for required directories
    local required_dirs=("hosts" "modules")
    for dir in "${required_dirs[@]}"; do
        [[ -d "$backup_path/$dir" ]] || error "Missing required directory in backup: $dir"
    done

    log "Backup validation passed"
}

create_current_backup() {
    local temp_backup_dir="${BACKUP_DIR}/rollback_temp_$(date '+%Y%m%d_%H%M%S')"

    log "Creating temporary backup of current state at $temp_backup_dir"

    # Use our backup script to create a backup of current state
    "$SCRIPT_DIR/refactor-backup" create --output "$(dirname "$temp_backup_dir")" >/dev/null

    # Find the most recent backup (which should be the one we just created)
    local latest_backup=$(find "$(dirname "$temp_backup_dir")" -name "backup_*" -type d | sort | tail -n1)

    echo "$latest_backup"
}

restore_from_backup() {
    local backup_path="$1"
    local dry_run="${2:-false}"
    local force="${3:-false}"

    validate_backup "$backup_path"

    # Show backup information
    echo "Backup Information:"
    if [[ -f "$backup_path/backup_metadata.json" ]]; then
        jq -r '"  Date: " + (.backup_date // "unknown")' "$backup_path/backup_metadata.json" 2>/dev/null || echo "  Date: unknown"
        jq -r '"  Commit: " + (.git_commit // "unknown")' "$backup_path/backup_metadata.json" 2>/dev/null || echo "  Commit: unknown"
        jq -r '"  Branch: " + (.git_branch // "unknown")' "$backup_path/backup_metadata.json" 2>/dev/null || echo "  Branch: unknown"
    fi
    echo

    if [[ "$dry_run" == true ]]; then
        echo "DRY RUN: Would restore the following files:"
        echo "  flake.nix"
        echo "  flake.lock"
        echo "  hosts/ (entire directory)"
        echo "  modules/ (entire directory)"
        echo
        echo "No changes made (dry run mode)."
        return 0
    fi

    # Create backup of current state before restoring
    local current_backup=""
    current_backup=$(create_current_backup)
    echo "Created backup of current state: $current_backup"
    echo

    confirm "This will replace your current configuration with the backup. Continue?" "$force"

    log "Starting restore from $backup_path"

    # Restore files
    log "Restoring flake.nix"
    cp "$backup_path/flake.nix" "$PROJECT_ROOT/"

    log "Restoring flake.lock"
    cp "$backup_path/flake.lock" "$PROJECT_ROOT/"

    # Restore directories (remove current and replace)
    log "Restoring hosts directory"
    rm -rf "$PROJECT_ROOT/hosts"
    cp -r "$backup_path/hosts" "$PROJECT_ROOT/"

    log "Restoring modules directory"
    rm -rf "$PROJECT_ROOT/modules"
    cp -r "$backup_path/modules" "$PROJECT_ROOT/"

    echo "Configuration restored successfully!"
    echo "Previous state backed up to: $current_backup"
    echo
    echo "To apply the restored configuration, run:"
    echo "  cd $PROJECT_ROOT"
    echo "  make build    # Test the configuration"
    echo "  make switch HOST=<your-host>   # Apply the configuration"
}

show_status() {
    local backup_path="$1"

    validate_backup "$backup_path"

    echo "Comparing current configuration with backup:"
    echo

    # Compare key files
    echo "File differences:"
    for file in "flake.nix" "flake.lock"; do
        if ! diff -q "$PROJECT_ROOT/$file" "$backup_path/$file" >/dev/null 2>&1; then
            echo "  $file: DIFFERENT"
        else
            echo "  $file: SAME"
        fi
    done

    echo
    echo "Current git status:"
    cd "$PROJECT_ROOT"
    if git rev-parse --git-dir >/dev/null 2>&1; then
        echo "  Commit: $(git rev-parse HEAD 2>/dev/null || echo 'unknown')"
        echo "  Branch: $(git branch --show-current 2>/dev/null || echo 'unknown')"

        local backup_commit=""
        if [[ -f "$backup_path/backup_metadata.json" ]]; then
            backup_commit=$(jq -r '.git_commit // "unknown"' "$backup_path/backup_metadata.json" 2>/dev/null || echo "unknown")
        fi

        if [[ "$backup_commit" != "unknown" ]]; then
            local current_commit=$(git rev-parse HEAD 2>/dev/null || echo 'unknown')
            if [[ "$current_commit" == "$backup_commit" ]]; then
                echo "  Status: At same commit as backup"
            else
                echo "  Status: Different commit than backup ($backup_commit)"
            fi
        fi
    else
        echo "  Status: Not a git repository"
    fi
}

list_backups() {
    local backup_dir="$1"

    if [[ ! -d "$backup_dir" ]]; then
        echo "No backups directory found at: $backup_dir"
        return 0
    fi

    echo "Available backups for restore in $backup_dir:"
    for backup in "$backup_dir"/backup_*; do
        if [[ -d "$backup" && -f "$backup/backup_metadata.json" ]]; then
            local timestamp=$(basename "$backup" | sed 's/backup_//')
            local date=$(jq -r '.backup_date // "unknown"' "$backup/backup_metadata.json" 2>/dev/null || echo "unknown")
            local commit=$(jq -r '.git_commit // "unknown"' "$backup/backup_metadata.json" 2>/dev/null || echo "unknown")
            local branch=$(jq -r '.git_branch // "unknown"' "$backup/backup_metadata.json" 2>/dev/null || echo "unknown")
            printf "  %-20s %s\n" "$timestamp" "$date"
            printf "  %-20s branch: %s, commit: %.8s\n" "" "$branch" "$commit"
            echo
        fi
    done
}

# Parse command line arguments
COMMAND=""
BACKUP_PATH=""
FORCE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        restore|status|list)
            COMMAND="$1"
            shift
            ;;
        --backup)
            BACKUP_PATH="$2"
            shift 2
            ;;
        --dry-run)
            DRY_RUN=true
            shift
            ;;
        --force)
            FORCE=true
            shift
            ;;
        --verbose)
            VERBOSE=true
            shift
            ;;
        --help)
            usage
            exit 0
            ;;
        *)
            error "Unknown option: $1"
            ;;
    esac
done

# Validate command
[[ -n "$COMMAND" ]] || { usage; exit 1; }

# Execute command
case "$COMMAND" in
    restore)
        [[ -n "$BACKUP_PATH" ]] || error "Backup path required for restore command. Use --backup <path>"
        restore_from_backup "$BACKUP_PATH" "$DRY_RUN" "$FORCE"
        ;;
    status)
        [[ -n "$BACKUP_PATH" ]] || error "Backup path required for status command. Use --backup <path>"
        show_status "$BACKUP_PATH"
        ;;
    list)
        list_backups "$BACKUP_DIR"
        ;;
    *)
        error "Unknown command: $COMMAND"
        ;;
esac
