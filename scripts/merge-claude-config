#!/bin/bash

set -euo pipefail

# 색상 코드
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# 설정
CLAUDE_DIR="$HOME/.claude"
SCRIPT_NAME="$(basename "$0")"

# 도움말 출력
show_help() {
    cat << EOF
${BLUE}Claude 설정 파일 병합 도구${NC}

이 도구는 dotfiles 업데이트로 인해 생성된 .new 파일들과
사용자가 수정한 기존 설정을 안전하게 병합할 수 있도록 도와줍니다.

${YELLOW}사용법:${NC}
    $SCRIPT_NAME [OPTIONS] [FILE]

${YELLOW}옵션:${NC}
    -h, --help      이 도움말 출력
    -l, --list      병합이 필요한 파일 목록 출력
    -a, --auto      자동 병합 시도 (신중히 사용)
    -d, --diff      차이점만 출력 (병합 안 함)
    -v, --verbose   자세한 출력

${YELLOW}인자:${NC}
    FILE           특정 파일만 병합 (예: settings.json)
                   생략 시 모든 .new 파일 처리

${YELLOW}예시:${NC}
    $SCRIPT_NAME                    # 모든 파일 대화형 병합
    $SCRIPT_NAME settings.json      # settings.json만 병합
    $SCRIPT_NAME -l                 # 병합 필요한 파일 목록
    $SCRIPT_NAME -d CLAUDE.md       # CLAUDE.md 차이점만 확인

${YELLOW}병합 프로세스:${NC}
1. 변경사항 확인 및 검토
2. 선택적 섹션 병합
3. 백업 생성
4. 최종 파일 적용
5. 임시 파일 정리
EOF
}

# 로그 함수들
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# 파일 존재 확인
check_file_exists() {
    local file="$1"
    if [[ ! -f "$file" ]]; then
        log_error "파일이 존재하지 않습니다: $file"
        return 1
    fi
    return 0
}

# 병합이 필요한 파일 목록 조회
find_merge_candidates() {
    local candidates=()

    for new_file in "$CLAUDE_DIR"/*.new; do
        if [[ -f "$new_file" ]]; then
            local base_file="${new_file%.new}"
            if [[ -f "$base_file" ]]; then
                candidates+=("$(basename "$base_file")")
            fi
        fi
    done

    for new_file in "$CLAUDE_DIR/commands"/*.new; do
        if [[ -f "$new_file" ]]; then
            local base_file="${new_file%.new}"
            if [[ -f "$base_file" ]]; then
                candidates+=("commands/$(basename "$base_file")")
            fi
        fi
    done

    printf '%s\n' "${candidates[@]}"
}

# 파일 차이점 출력
show_diff() {
    local current_file="$1"
    local new_file="$2"
    local file_name="$(basename "$current_file")"

    echo ""
    echo -e "${BLUE}=== $file_name 변경사항 ===ND{NC}"

    if command -v colordiff >/dev/null 2>&1; then
        colordiff -u "$current_file" "$new_file" || true
    else
        diff -u "$current_file" "$new_file" || true
    fi

    echo ""
}

# 백업 생성
create_backup() {
    local file="$1"
    local backup_dir="$CLAUDE_DIR/.backups"
    local timestamp=$(date +%Y%m%d_%H%M%S)
    local backup_file="$backup_dir/$(basename "$file").backup.$timestamp"

    mkdir -p "$backup_dir"
    cp "$file" "$backup_file"
    log_success "백업 생성됨: $backup_file"
    echo "$backup_file"
}

# JSON 파일 병합 (settings.json용)
merge_json_interactive() {
    local current_file="$1"
    local new_file="$2"
    local output_file="$3"

    log_info "JSON 설정 파일 병합: $(basename "$current_file")"

    # jq가 설치되어 있는지 확인
    if ! command -v jq >/dev/null 2>&1; then
        log_warning "jq가 설치되지 않음. 텍스트 병합으로 진행합니다."
        return 1
    fi

    # JSON 유효성 검사
    if ! jq empty "$current_file" 2>/dev/null; then
        log_warning "현재 파일이 유효한 JSON이 아닙니다."
        return 1
    fi

    if ! jq empty "$new_file" 2>/dev/null; then
        log_warning "새 파일이 유효한 JSON이 아닙니다."
        return 1
    fi

    # 키별로 병합 옵션 제공
    echo ""
    echo "JSON 키별 병합 옵션을 선택하세요:"
    echo "c) 현재 값 유지"
    echo "n) 새 값 사용"
    echo "s) 건너뛰기"
    echo ""

    # 새 파일의 모든 키를 추출
    local new_keys
    new_keys=$(jq -r 'keys[]' "$new_file")

    # 현재 파일을 베이스로 시작
    cp "$current_file" "$output_file"

    while IFS= read -r key; do
        local current_value
        local new_value

        current_value=$(jq -r ".$key // null" "$current_file")
        new_value=$(jq -r ".$key" "$new_file")

        if [[ "$current_value" != "$new_value" ]]; then
            echo ""
            echo -e "${YELLOW}키: $key${NC}"
            echo "현재 값: $current_value"
            echo "새 값: $new_value"

            while true; do
                read -p "선택 [c/n/s]: " choice
                case $choice in
                    c|C)
                        # 현재 값 유지 (이미 output_file에 있음)
                        log_info "현재 값 유지: $key"
                        break
                        ;;
                    n|N)
                        # 새 값 적용
                        local escaped_key
                        escaped_key=$(printf '%s' "$key" | jq -R .)
                        jq ".$key = $(jq ".$key" "$new_file")" "$output_file" > "$output_file.tmp"
                        mv "$output_file.tmp" "$output_file"
                        log_info "새 값 적용: $key"
                        break
                        ;;
                    s|S)
                        log_info "건너뛰기: $key"
                        break
                        ;;
                    *)
                        echo "c, n, 또는 s를 입력하세요."
                        ;;
                esac
            done
        fi
    done <<< "$new_keys"

    # 새 파일에만 있는 키들 추가
    local current_keys
    current_keys=$(jq -r 'keys[]' "$current_file")

    while IFS= read -r key; do
        if ! echo "$current_keys" | grep -q "^$key$"; then
            echo ""
            echo -e "${YELLOW}새 키 발견: $key${NC}"
            local new_value
            new_value=$(jq -r ".$key" "$new_file")
            echo "값: $new_value"

            while true; do
                read -p "추가하시겠습니까? [y/n]: " choice
                case $choice in
                    y|Y)
                        local escaped_key
                        escaped_key=$(printf '%s' "$key" | jq -R .)
                        jq ".$key = $(jq ".$key" "$new_file")" "$output_file" > "$output_file.tmp"
                        mv "$output_file.tmp" "$output_file"
                        log_info "새 키 추가: $key"
                        break
                        ;;
                    n|N)
                        log_info "새 키 건너뛰기: $key"
                        break
                        ;;
                    *)
                        echo "y 또는 n을 입력하세요."
                        ;;
                esac
            done
        fi
    done <<< "$new_keys"

    log_success "JSON 병합 완료"
    return 0
}

# 텍스트 파일 대화형 병합
merge_text_interactive() {
    local current_file="$1"
    local new_file="$2"
    local output_file="$3"
    local file_name="$(basename "$current_file")"

    log_info "텍스트 파일 병합: $file_name"

    echo ""
    echo "병합 방법을 선택하세요:"
    echo "1) 현재 파일 유지 (변경사항 무시)"
    echo "2) 새 파일로 교체 (사용자 수정사항 손실)"
    echo "3) 외부 에디터로 수동 병합"
    echo "4) 섹션별 선택 병합"
    echo "5) 건너뛰기"
    echo ""

    while true; do
        read -p "선택하세요 [1-5]: " choice
        case $choice in
            1)
                cp "$current_file" "$output_file"
                log_success "현재 파일 유지됨"
                return 0
                ;;
            2)
                cp "$new_file" "$output_file"
                log_warning "새 파일로 교체됨 (사용자 수정사항 손실)"
                return 0
                ;;
            3)
                # 외부 에디터 사용
                if command -v $EDITOR >/dev/null 2>&1; then
                    cp "$current_file" "$output_file"
                    log_info "에디터로 파일을 열어서 수동으로 병합하세요."
                    log_info "참고할 새 파일: $new_file"
                    read -p "계속하려면 Enter를 누르세요..."
                    $EDITOR "$output_file"
                    log_success "수동 병합 완료"
                    return 0
                else
                    log_error "EDITOR 환경변수가 설정되지 않았습니다."
                    continue
                fi
                ;;
            4)
                # 섹션별 병합은 복잡하므로 기본 옵션으로 대체
                log_warning "섹션별 병합은 외부 도구를 사용하세요: vimdiff '$current_file' '$new_file'"
                cp "$current_file" "$output_file"
                return 0
                ;;
            5)
                log_info "병합 건너뛰기"
                return 1
                ;;
            *)
                echo "1-5 중에서 선택하세요."
                ;;
        esac
    done
}

# 단일 파일 병합
merge_file() {
    local file_name="$1"
    local current_file="$CLAUDE_DIR/$file_name"
    local new_file="$CLAUDE_DIR/${file_name}.new"
    local notice_file="$CLAUDE_DIR/${file_name}.update-notice"

    # 파일 존재 확인
    if [[ ! -f "$current_file" ]]; then
        log_error "현재 파일이 존재하지 않습니다: $file_name"
        return 1
    fi

    if [[ ! -f "$new_file" ]]; then
        log_error "새 파일이 존재하지 않습니다: ${file_name}.new"
        return 1
    fi

    echo ""
    echo -e "${BLUE}=== $file_name 병합 시작 ===${NC}"

    # 차이점 출력
    show_diff "$current_file" "$new_file"

    # 백업 생성
    local backup_file
    backup_file=$(create_backup "$current_file")

    # 임시 출력 파일
    local temp_output="$current_file.merge.tmp"

    # 파일 타입에 따른 병합
    local merge_success=false

    if [[ "$file_name" == "settings.json" ]]; then
        if merge_json_interactive "$current_file" "$new_file" "$temp_output"; then
            merge_success=true
        fi
    fi

    # JSON 병합 실패 시 또는 다른 파일 타입인 경우 텍스트 병합
    if [[ "$merge_success" != "true" ]]; then
        if merge_text_interactive "$current_file" "$new_file" "$temp_output"; then
            merge_success=true
        fi
    fi

    if [[ "$merge_success" == "true" ]]; then
        # 병합된 파일 적용
        mv "$temp_output" "$current_file"
        chmod 644 "$current_file"

        # 정리
        rm -f "$new_file"
        rm -f "$notice_file"

        log_success "$file_name 병합 완료"
        echo "백업 파일: $backup_file"
        return 0
    else
        # 병합 실패 시 정리
        rm -f "$temp_output"
        log_info "$file_name 병합 건너뛰기"
        return 1
    fi
}

# 자동 병합 (간단한 케이스만)
auto_merge_file() {
    local file_name="$1"
    local current_file="$CLAUDE_DIR/$file_name"
    local new_file="$CLAUDE_DIR/${file_name}.new"

    log_info "자동 병합 시도: $file_name"

    # 현재는 안전을 위해 자동 병합 비활성화
    log_warning "자동 병합은 현재 지원되지 않습니다. 대화형 병합을 사용하세요."
    return 1
}

# 메인 함수
main() {
    local auto_mode=false
    local list_only=false
    local diff_only=false
    local verbose=false
    local target_file=""

    # 옵션 파싱
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -l|--list)
                list_only=true
                shift
                ;;
            -a|--auto)
                auto_mode=true
                shift
                ;;
            -d|--diff)
                diff_only=true
                shift
                ;;
            -v|--verbose)
                verbose=true
                shift
                ;;
            -*)
                log_error "알 수 없는 옵션: $1"
                echo "도움말을 보려면 $SCRIPT_NAME --help를 실행하세요."
                exit 1
                ;;
            *)
                target_file="$1"
                shift
                ;;
        esac
    done

    # Claude 디렉토리 존재 확인
    if [[ ! -d "$CLAUDE_DIR" ]]; then
        log_error "Claude 디렉토리가 존재하지 않습니다: $CLAUDE_DIR"
        exit 1
    fi

    # 병합 후보 파일 찾기
    local candidates
    candidates=()
    while IFS= read -r line; do
        candidates+=("$line")
    done < <(find_merge_candidates)

    if [[ ${#candidates[@]} -eq 0 ]]; then
        log_info "병합이 필요한 파일이 없습니다."
        exit 0
    fi

    # 목록만 출력
    if [[ "$list_only" == "true" ]]; then
        echo "병합이 필요한 파일:"
        printf '  %s\n' "${candidates[@]}"
        exit 0
    fi

    # 특정 파일 지정 시 해당 파일만 처리
    if [[ -n "$target_file" ]]; then
        # candidates에 있는지 확인
        local found=false
        for candidate in "${candidates[@]}"; do
            if [[ "$candidate" == "$target_file" ]]; then
                found=true
                break
            fi
        done

        if [[ "$found" != "true" ]]; then
            log_error "$target_file은 병합 후보에 없습니다."
            log_info "사용 가능한 파일: ${candidates[*]}"
            exit 1
        fi

        candidates=("$target_file")
    fi

    # 차이점만 출력
    if [[ "$diff_only" == "true" ]]; then
        for file_name in "${candidates[@]}"; do
            local current_file="$CLAUDE_DIR/$file_name"
            local new_file="$CLAUDE_DIR/${file_name}.new"
            show_diff "$current_file" "$new_file"
        done
        exit 0
    fi

    # 병합 시작
    echo -e "${BLUE}Claude 설정 파일 병합 도구${NC}"
    echo "병합할 파일 ${#candidates[@]}개 발견"
    echo ""

    local success_count=0
    local skip_count=0

    for file_name in "${candidates[@]}"; do
        if [[ "$auto_mode" == "true" ]]; then
            if auto_merge_file "$file_name"; then
                ((success_count++))
            else
                ((skip_count++))
            fi
        else
            if merge_file "$file_name"; then
                ((success_count++))
            else
                ((skip_count++))
            fi
        fi
    done

    # 결과 요약
    echo ""
    echo -e "${BLUE}=== 병합 완료 ===${NC}"
    echo "성공: $success_count개"
    echo "건너뜀: $skip_count개"

    if [[ $success_count -gt 0 ]]; then
        echo ""
        log_success "병합이 완료되었습니다!"
        log_info "백업 파일들은 $CLAUDE_DIR/.backups/ 에 저장되었습니다."
    fi
}

# 스크립트 실행
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    main "$@"
fi
